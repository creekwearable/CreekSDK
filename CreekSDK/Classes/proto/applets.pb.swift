// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: applets.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct protocol_min_program_list_item: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///小程序类型
  public var type: min_program_type = .null

  ///4bytes 小程序版本号
  public var version: UInt32 = 0

  ///4bytes 小程序所占大小
  public var size: UInt32 = 0

  ///max:30 小程序名字
  public var name: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_min_program_operate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型
  public var operate: min_program_operate_type = .inquire

  ///max:30 小程序名字
  public var appName: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_min_program_inquire_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型
  public var operate: min_program_operate_type = .inquire

  ///1bytes 计算方式 0：内存大小计算 1：按个数计算
  public var formulaMode: UInt32 = 0

  ///1bytes 框架版本号
  public var frameworkVersion: UInt32 = 0

  ///1bytes 小程序的总个数
  public var totalNum: UInt32 = 0

  ///1bytes 小程序的已经使用个数
  public var usedNum: UInt32 = 0

  ///1bytes 表盘小程序的已经使用个数
  public var usedDialNum: UInt32 = 0

  ///1bytes 普通小程序的已经使用个数
  public var userGeneralNum: UInt32 = 0

  ///4bytes 小程序所占的总大小
  public var totalSize: UInt32 = 0

  ///4bytes  表盘小程序使用空间  单位byte
  public var usedDialSize: UInt32 = 0

  ///4bytes  普通小程序使用空间  单位byte
  public var usedGeneralSize: UInt32 = 0

  ///1bytes 压缩类型，0代表不压缩，4代表使用LZ4的压缩方式
  public var enableCompress: UInt32 = 0

  ///1bytes 所有小程序支持最大个数
  public var allSupportMaxNum: UInt32 = 0

  public var listItem: [protocol_min_program_list_item] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_http_request: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 请求类型
  public var method: http_request_method = .post

  ///1bytes http版本
  public var version: UInt32 = 0

  ///2bytes 超时时间（秒）
  public var timeout: UInt32 = 0

  ///发送数据头
  public var headers: Data = Data()

  ///128bytes 请求的http链接
  public var url: Data = Data()

  ///请求体
  public var body: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_http_reply: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///2bytes 返回的请求http状态码
  public var status: UInt32 = 0

  ///接收数据头
  public var headers: Data = Data()

  ///回复体
  public var body: Data = Data()

  ///文件名（可选）
  public var filename: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension protocol_min_program_list_item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_min_program_list_item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "version"),
    3: .same(proto: "size"),
    4: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.size) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .null {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 2)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt32Field(value: self.size, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularBytesField(value: self.name, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_min_program_list_item, rhs: protocol_min_program_list_item) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.version != rhs.version {return false}
    if lhs.size != rhs.size {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_min_program_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_min_program_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "app_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.appName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .inquire {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if !self.appName.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.appName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_min_program_operate, rhs: protocol_min_program_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.appName != rhs.appName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_min_program_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_min_program_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "formula_mode"),
    3: .standard(proto: "framework_version"),
    4: .standard(proto: "total_num"),
    5: .standard(proto: "used_num"),
    6: .standard(proto: "used_dial_num"),
    7: .standard(proto: "user_general_num"),
    8: .standard(proto: "total_size"),
    9: .standard(proto: "used_dial_size"),
    10: .standard(proto: "used_general_size"),
    11: .standard(proto: "enable_compress"),
    12: .standard(proto: "all_support_max_num"),
    13: .standard(proto: "list_item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.formulaMode) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.frameworkVersion) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.totalNum) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.usedNum) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.usedDialNum) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.userGeneralNum) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.totalSize) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.usedDialSize) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.usedGeneralSize) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self.enableCompress) }()
      case 12: try { try decoder.decodeSingularUInt32Field(value: &self.allSupportMaxNum) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.listItem) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .inquire {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.formulaMode != 0 {
      try visitor.visitSingularUInt32Field(value: self.formulaMode, fieldNumber: 2)
    }
    if self.frameworkVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.frameworkVersion, fieldNumber: 3)
    }
    if self.totalNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalNum, fieldNumber: 4)
    }
    if self.usedNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.usedNum, fieldNumber: 5)
    }
    if self.usedDialNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.usedDialNum, fieldNumber: 6)
    }
    if self.userGeneralNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.userGeneralNum, fieldNumber: 7)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalSize, fieldNumber: 8)
    }
    if self.usedDialSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.usedDialSize, fieldNumber: 9)
    }
    if self.usedGeneralSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.usedGeneralSize, fieldNumber: 10)
    }
    if self.enableCompress != 0 {
      try visitor.visitSingularUInt32Field(value: self.enableCompress, fieldNumber: 11)
    }
    if self.allSupportMaxNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.allSupportMaxNum, fieldNumber: 12)
    }
    if !self.listItem.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.listItem, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_min_program_inquire_reply, rhs: protocol_min_program_inquire_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.formulaMode != rhs.formulaMode {return false}
    if lhs.frameworkVersion != rhs.frameworkVersion {return false}
    if lhs.totalNum != rhs.totalNum {return false}
    if lhs.usedNum != rhs.usedNum {return false}
    if lhs.usedDialNum != rhs.usedDialNum {return false}
    if lhs.userGeneralNum != rhs.userGeneralNum {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.usedDialSize != rhs.usedDialSize {return false}
    if lhs.usedGeneralSize != rhs.usedGeneralSize {return false}
    if lhs.enableCompress != rhs.enableCompress {return false}
    if lhs.allSupportMaxNum != rhs.allSupportMaxNum {return false}
    if lhs.listItem != rhs.listItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_http_request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_http_request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "method"),
    2: .same(proto: "version"),
    3: .same(proto: "timeout"),
    4: .same(proto: "headers"),
    5: .same(proto: "url"),
    6: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.method) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.timeout) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.headers) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.url) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.method != .post {
      try visitor.visitSingularEnumField(value: self.method, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 2)
    }
    if self.timeout != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeout, fieldNumber: 3)
    }
    if !self.headers.isEmpty {
      try visitor.visitSingularBytesField(value: self.headers, fieldNumber: 4)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularBytesField(value: self.url, fieldNumber: 5)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularBytesField(value: self.body, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_http_request, rhs: protocol_http_request) -> Bool {
    if lhs.method != rhs.method {return false}
    if lhs.version != rhs.version {return false}
    if lhs.timeout != rhs.timeout {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.url != rhs.url {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_http_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_http_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "headers"),
    3: .same(proto: "body"),
    4: .same(proto: "filename"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.status) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.headers) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.body) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.filename) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != 0 {
      try visitor.visitSingularUInt32Field(value: self.status, fieldNumber: 1)
    }
    if !self.headers.isEmpty {
      try visitor.visitSingularBytesField(value: self.headers, fieldNumber: 2)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularBytesField(value: self.body, fieldNumber: 3)
    }
    if !self.filename.isEmpty {
      try visitor.visitSingularBytesField(value: self.filename, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_http_reply, rhs: protocol_http_reply) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.body != rhs.body {return false}
    if lhs.filename != rhs.filename {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
