// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: userinfo.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct protocol_personal_info: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 身高
  public var height: UInt32 = 0

  ///2bytes 体重  kg有小数点，设定值为实际体重的扩大一百倍
  public var weight: UInt32 = 0

  ///1bytes 性别 0: 男性 1:女性
  public var gender: gender_type = .genderMale

  ///2bytes //生日年份
  public var year: UInt32 = 0

  ///1bytes
  public var month: UInt32 = 0

  ///1bytes
  public var day: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_perferences: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes  距离单位0x00：无效 0x01：km， 0x02:mi
  public var distUnit: UInt32 = 0

  ///1bytes  体重单位： 0x00：无效，0x01：kg， 0x02:lb， 0x03:英石）
  public var weightUnit: UInt32 = 0

  ///1bytes  天气温度单位 0x00：无效 0x01:℃， 0x02:℉
  public var airTempUnit: UInt32 = 0

  ///1bytes 体温温度单位 0x00：无效 0x01:℃， 0x02:℉
  public var skinTempUnit: UInt32 = 0

  ///1bytes 时间制式（0x00：无效<br>0x01：24小时制，0x02：12小时制）
  public var is12HourFormat: UInt32 = 0

  ///1bytes 周起始日 0x00 星期1,0x01 星期天,,0x02 星期6
  public var weekStartDay: UInt32 = 0

  ///1bytes 卡路里单位设置 0 无效，  1：默认千卡； 2：大卡； 3：千焦
  public var calorieUnit: UInt32 = 0

  ///1bytes 泳池单位设置 0 无效，  1：默认米； 2：码
  public var swimPoolUnit: UInt32 = 0

  ///1bytes 骑行的单位（公里/英里） 0 无效； 1：km 公里； 2：英里 ；
  public var cyclingUnit: UInt32 = 0

  ///1bytes 步行或者跑步的单位（公里/英里）设置  0 无效； 1：km 公里； 2：英里；
  public var walkingRunningUnit: UInt32 = 0

  ///1bytes 步幅单位
  public var strideUnit: UInt32 = 0

  ///1bytes 身高单位 0x00：无效 0x01，厘米cm 0x02,英寸ft
  public var heightUnit: UInt32 = 0

  ///1bytes 海拔高度单位 0x00：无效 0x01，米m 0x02,英尺ft
  public var altitudeUnit: UInt32 = 0

  ///1bytes 风速单位 0x00：无效 0x01，米/秒（m/s） 0x02,千米/小时（km/h）
  public var windSpeedUnit: UInt32 = 0

  ///1bytes 能见度单位 0x00：无效 0x01,米（m） 0x02,千米（km） 0x03,英里（mi）
  public var visibilityUnit: UInt32 = 0

  ///1bytes 血压单位 0x00：无效 0x01,毫米汞柱（mmhg）0x02,千帕（kpa）
  public var bloodPressureUnit: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_goal_setting: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 锻炼时长目标
  public var exerciseMin: UInt32 = 0

  ///1bytes 站立小时目标
  public var standingHour: UInt32 = 0

  ///2bytes 卡路里目标
  public var kcal: UInt32 = 0

  ///4bytes 步数目标
  public var steps: UInt32 = 0

  ///4bytes 距离目标 单位米
  public var distance: UInt32 = 0

  ///1bytes 运动天数目标
  public var workoutDay: UInt32 = 0

  ///1bytes 目标提醒开关 true 开启,false 关闭
  public var notifySwitchFlag: Bool = false

  ///1bytes 通知类型
  public var notifyFlag: notify_type = .allow

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_user_info_operate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type {
    get {return _storage._operate}
    set {_uniqueStorage()._operate = newValue}
  }

  ///个人信息
  public var personalInfo: protocol_personal_info {
    get {return _storage._personalInfo ?? protocol_personal_info()}
    set {_uniqueStorage()._personalInfo = newValue}
  }
  /// Returns true if `personalInfo` has been explicitly set.
  public var hasPersonalInfo: Bool {return _storage._personalInfo != nil}
  /// Clears the value of `personalInfo`. Subsequent reads from it will return its default value.
  public mutating func clearPersonalInfo() {_uniqueStorage()._personalInfo = nil}

  ///单位设置
  public var perferences: protocol_perferences {
    get {return _storage._perferences ?? protocol_perferences()}
    set {_uniqueStorage()._perferences = newValue}
  }
  /// Returns true if `perferences` has been explicitly set.
  public var hasPerferences: Bool {return _storage._perferences != nil}
  /// Clears the value of `perferences`. Subsequent reads from it will return its default value.
  public mutating func clearPerferences() {_uniqueStorage()._perferences = nil}

  ///目标设置
  public var goalSetting: protocol_goal_setting {
    get {return _storage._goalSetting ?? protocol_goal_setting()}
    set {_uniqueStorage()._goalSetting = newValue}
  }
  /// Returns true if `goalSetting` has been explicitly set.
  public var hasGoalSetting: Bool {return _storage._goalSetting != nil}
  /// Clears the value of `goalSetting`. Subsequent reads from it will return its default value.
  public mutating func clearGoalSetting() {_uniqueStorage()._goalSetting = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct protocol_user_info_inquire_reply: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 功能表
  public var funcTable: UInt32 {
    get {return _storage._funcTable}
    set {_uniqueStorage()._funcTable = newValue}
  }

  ///操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type {
    get {return _storage._operate}
    set {_uniqueStorage()._operate = newValue}
  }

  ///个人信息
  public var personalInfo: protocol_personal_info {
    get {return _storage._personalInfo ?? protocol_personal_info()}
    set {_uniqueStorage()._personalInfo = newValue}
  }
  /// Returns true if `personalInfo` has been explicitly set.
  public var hasPersonalInfo: Bool {return _storage._personalInfo != nil}
  /// Clears the value of `personalInfo`. Subsequent reads from it will return its default value.
  public mutating func clearPersonalInfo() {_uniqueStorage()._personalInfo = nil}

  ///单位设置
  public var perferences: protocol_perferences {
    get {return _storage._perferences ?? protocol_perferences()}
    set {_uniqueStorage()._perferences = newValue}
  }
  /// Returns true if `perferences` has been explicitly set.
  public var hasPerferences: Bool {return _storage._perferences != nil}
  /// Clears the value of `perferences`. Subsequent reads from it will return its default value.
  public mutating func clearPerferences() {_uniqueStorage()._perferences = nil}

  ///目标设置
  public var goalSetting: protocol_goal_setting {
    get {return _storage._goalSetting ?? protocol_goal_setting()}
    set {_uniqueStorage()._goalSetting = newValue}
  }
  /// Returns true if `goalSetting` has been explicitly set.
  public var hasGoalSetting: Bool {return _storage._goalSetting != nil}
  /// Clears the value of `goalSetting`. Subsequent reads from it will return its default value.
  public mutating func clearGoalSetting() {_uniqueStorage()._goalSetting = nil}

  ///用户图片宽度
  public var userIconWidth: UInt32 {
    get {return _storage._userIconWidth}
    set {_uniqueStorage()._userIconWidth = newValue}
  }

  ///用户图片高度
  public var userIconHeight: UInt32 {
    get {return _storage._userIconHeight}
    set {_uniqueStorage()._userIconHeight = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension protocol_personal_info: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_personal_info"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "weight"),
    3: .same(proto: "gender"),
    4: .same(proto: "year"),
    5: .same(proto: "month"),
    6: .same(proto: "day"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.weight) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.gender) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.year) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.month) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.day) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 1)
    }
    if self.weight != 0 {
      try visitor.visitSingularUInt32Field(value: self.weight, fieldNumber: 2)
    }
    if self.gender != .genderMale {
      try visitor.visitSingularEnumField(value: self.gender, fieldNumber: 3)
    }
    if self.year != 0 {
      try visitor.visitSingularUInt32Field(value: self.year, fieldNumber: 4)
    }
    if self.month != 0 {
      try visitor.visitSingularUInt32Field(value: self.month, fieldNumber: 5)
    }
    if self.day != 0 {
      try visitor.visitSingularUInt32Field(value: self.day, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_personal_info, rhs: protocol_personal_info) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs.gender != rhs.gender {return false}
    if lhs.year != rhs.year {return false}
    if lhs.month != rhs.month {return false}
    if lhs.day != rhs.day {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_perferences: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_perferences"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dist_unit"),
    2: .standard(proto: "weight_unit"),
    3: .standard(proto: "air_temp_unit"),
    4: .standard(proto: "skin_temp_unit"),
    5: .standard(proto: "is_12hour_format"),
    6: .standard(proto: "week_start_day"),
    7: .standard(proto: "calorie_unit"),
    8: .standard(proto: "swim_pool_unit"),
    9: .standard(proto: "cycling_unit"),
    10: .standard(proto: "walking_running_unit"),
    11: .standard(proto: "stride_unit"),
    12: .standard(proto: "height_unit"),
    13: .standard(proto: "altitude_unit"),
    14: .standard(proto: "wind_speed_unit"),
    15: .standard(proto: "visibility_unit"),
    16: .standard(proto: "blood_pressure_unit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.distUnit) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.weightUnit) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.airTempUnit) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.skinTempUnit) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.is12HourFormat) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.weekStartDay) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.calorieUnit) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.swimPoolUnit) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.cyclingUnit) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.walkingRunningUnit) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self.strideUnit) }()
      case 12: try { try decoder.decodeSingularUInt32Field(value: &self.heightUnit) }()
      case 13: try { try decoder.decodeSingularUInt32Field(value: &self.altitudeUnit) }()
      case 14: try { try decoder.decodeSingularUInt32Field(value: &self.windSpeedUnit) }()
      case 15: try { try decoder.decodeSingularUInt32Field(value: &self.visibilityUnit) }()
      case 16: try { try decoder.decodeSingularUInt32Field(value: &self.bloodPressureUnit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.distUnit != 0 {
      try visitor.visitSingularUInt32Field(value: self.distUnit, fieldNumber: 1)
    }
    if self.weightUnit != 0 {
      try visitor.visitSingularUInt32Field(value: self.weightUnit, fieldNumber: 2)
    }
    if self.airTempUnit != 0 {
      try visitor.visitSingularUInt32Field(value: self.airTempUnit, fieldNumber: 3)
    }
    if self.skinTempUnit != 0 {
      try visitor.visitSingularUInt32Field(value: self.skinTempUnit, fieldNumber: 4)
    }
    if self.is12HourFormat != 0 {
      try visitor.visitSingularUInt32Field(value: self.is12HourFormat, fieldNumber: 5)
    }
    if self.weekStartDay != 0 {
      try visitor.visitSingularUInt32Field(value: self.weekStartDay, fieldNumber: 6)
    }
    if self.calorieUnit != 0 {
      try visitor.visitSingularUInt32Field(value: self.calorieUnit, fieldNumber: 7)
    }
    if self.swimPoolUnit != 0 {
      try visitor.visitSingularUInt32Field(value: self.swimPoolUnit, fieldNumber: 8)
    }
    if self.cyclingUnit != 0 {
      try visitor.visitSingularUInt32Field(value: self.cyclingUnit, fieldNumber: 9)
    }
    if self.walkingRunningUnit != 0 {
      try visitor.visitSingularUInt32Field(value: self.walkingRunningUnit, fieldNumber: 10)
    }
    if self.strideUnit != 0 {
      try visitor.visitSingularUInt32Field(value: self.strideUnit, fieldNumber: 11)
    }
    if self.heightUnit != 0 {
      try visitor.visitSingularUInt32Field(value: self.heightUnit, fieldNumber: 12)
    }
    if self.altitudeUnit != 0 {
      try visitor.visitSingularUInt32Field(value: self.altitudeUnit, fieldNumber: 13)
    }
    if self.windSpeedUnit != 0 {
      try visitor.visitSingularUInt32Field(value: self.windSpeedUnit, fieldNumber: 14)
    }
    if self.visibilityUnit != 0 {
      try visitor.visitSingularUInt32Field(value: self.visibilityUnit, fieldNumber: 15)
    }
    if self.bloodPressureUnit != 0 {
      try visitor.visitSingularUInt32Field(value: self.bloodPressureUnit, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_perferences, rhs: protocol_perferences) -> Bool {
    if lhs.distUnit != rhs.distUnit {return false}
    if lhs.weightUnit != rhs.weightUnit {return false}
    if lhs.airTempUnit != rhs.airTempUnit {return false}
    if lhs.skinTempUnit != rhs.skinTempUnit {return false}
    if lhs.is12HourFormat != rhs.is12HourFormat {return false}
    if lhs.weekStartDay != rhs.weekStartDay {return false}
    if lhs.calorieUnit != rhs.calorieUnit {return false}
    if lhs.swimPoolUnit != rhs.swimPoolUnit {return false}
    if lhs.cyclingUnit != rhs.cyclingUnit {return false}
    if lhs.walkingRunningUnit != rhs.walkingRunningUnit {return false}
    if lhs.strideUnit != rhs.strideUnit {return false}
    if lhs.heightUnit != rhs.heightUnit {return false}
    if lhs.altitudeUnit != rhs.altitudeUnit {return false}
    if lhs.windSpeedUnit != rhs.windSpeedUnit {return false}
    if lhs.visibilityUnit != rhs.visibilityUnit {return false}
    if lhs.bloodPressureUnit != rhs.bloodPressureUnit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_goal_setting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_goal_setting"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exercise_min"),
    2: .standard(proto: "standing_hour"),
    3: .same(proto: "kcal"),
    4: .same(proto: "steps"),
    5: .same(proto: "distance"),
    6: .standard(proto: "workout_day"),
    7: .standard(proto: "notify_switch_flag"),
    8: .standard(proto: "notify_flag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.exerciseMin) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.standingHour) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.kcal) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.steps) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.distance) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.workoutDay) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.notifySwitchFlag) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.notifyFlag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.exerciseMin != 0 {
      try visitor.visitSingularUInt32Field(value: self.exerciseMin, fieldNumber: 1)
    }
    if self.standingHour != 0 {
      try visitor.visitSingularUInt32Field(value: self.standingHour, fieldNumber: 2)
    }
    if self.kcal != 0 {
      try visitor.visitSingularUInt32Field(value: self.kcal, fieldNumber: 3)
    }
    if self.steps != 0 {
      try visitor.visitSingularUInt32Field(value: self.steps, fieldNumber: 4)
    }
    if self.distance != 0 {
      try visitor.visitSingularUInt32Field(value: self.distance, fieldNumber: 5)
    }
    if self.workoutDay != 0 {
      try visitor.visitSingularUInt32Field(value: self.workoutDay, fieldNumber: 6)
    }
    if self.notifySwitchFlag != false {
      try visitor.visitSingularBoolField(value: self.notifySwitchFlag, fieldNumber: 7)
    }
    if self.notifyFlag != .allow {
      try visitor.visitSingularEnumField(value: self.notifyFlag, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_goal_setting, rhs: protocol_goal_setting) -> Bool {
    if lhs.exerciseMin != rhs.exerciseMin {return false}
    if lhs.standingHour != rhs.standingHour {return false}
    if lhs.kcal != rhs.kcal {return false}
    if lhs.steps != rhs.steps {return false}
    if lhs.distance != rhs.distance {return false}
    if lhs.workoutDay != rhs.workoutDay {return false}
    if lhs.notifySwitchFlag != rhs.notifySwitchFlag {return false}
    if lhs.notifyFlag != rhs.notifyFlag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_user_info_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_user_info_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "personal_info"),
    3: .same(proto: "perferences"),
    4: .standard(proto: "goal_setting"),
  ]

  fileprivate class _StorageClass {
    var _operate: operate_type = .invalid
    var _personalInfo: protocol_personal_info? = nil
    var _perferences: protocol_perferences? = nil
    var _goalSetting: protocol_goal_setting? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _operate = source._operate
      _personalInfo = source._personalInfo
      _perferences = source._perferences
      _goalSetting = source._goalSetting
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._operate) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._personalInfo) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._perferences) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._goalSetting) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._operate != .invalid {
        try visitor.visitSingularEnumField(value: _storage._operate, fieldNumber: 1)
      }
      try { if let v = _storage._personalInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._perferences {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._goalSetting {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_user_info_operate, rhs: protocol_user_info_operate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._operate != rhs_storage._operate {return false}
        if _storage._personalInfo != rhs_storage._personalInfo {return false}
        if _storage._perferences != rhs_storage._perferences {return false}
        if _storage._goalSetting != rhs_storage._goalSetting {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_user_info_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_user_info_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "func_table"),
    2: .same(proto: "operate"),
    3: .standard(proto: "personal_info"),
    4: .same(proto: "perferences"),
    5: .standard(proto: "goal_setting"),
    6: .standard(proto: "user_icon_width"),
    7: .standard(proto: "user_icon_height"),
  ]

  fileprivate class _StorageClass {
    var _funcTable: UInt32 = 0
    var _operate: operate_type = .invalid
    var _personalInfo: protocol_personal_info? = nil
    var _perferences: protocol_perferences? = nil
    var _goalSetting: protocol_goal_setting? = nil
    var _userIconWidth: UInt32 = 0
    var _userIconHeight: UInt32 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _funcTable = source._funcTable
      _operate = source._operate
      _personalInfo = source._personalInfo
      _perferences = source._perferences
      _goalSetting = source._goalSetting
      _userIconWidth = source._userIconWidth
      _userIconHeight = source._userIconHeight
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._funcTable) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._operate) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._personalInfo) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._perferences) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._goalSetting) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._userIconWidth) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._userIconHeight) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._funcTable != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._funcTable, fieldNumber: 1)
      }
      if _storage._operate != .invalid {
        try visitor.visitSingularEnumField(value: _storage._operate, fieldNumber: 2)
      }
      try { if let v = _storage._personalInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._perferences {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._goalSetting {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._userIconWidth != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._userIconWidth, fieldNumber: 6)
      }
      if _storage._userIconHeight != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._userIconHeight, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_user_info_inquire_reply, rhs: protocol_user_info_inquire_reply) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._funcTable != rhs_storage._funcTable {return false}
        if _storage._operate != rhs_storage._operate {return false}
        if _storage._personalInfo != rhs_storage._personalInfo {return false}
        if _storage._perferences != rhs_storage._perferences {return false}
        if _storage._goalSetting != rhs_storage._goalSetting {return false}
        if _storage._userIconWidth != rhs_storage._userIconWidth {return false}
        if _storage._userIconHeight != rhs_storage._userIconHeight {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
