// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: skill.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct protocol_skill_control_exercise_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///运动类型
  public var sportType: sport_type = .orun

  ///控制类型
  public var controlType: skill_control_type = .skillControlStart

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct skill_timer_item: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var index: UInt32 = 0

  public var timerSec: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_skill_timer_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///定时器操作
  public var timerOperate: skill_timer_operate = .timerInsertTimer

  ///定时器编号
  public var index: UInt32 = 0

  ///定时时间 单位秒
  public var timerSec: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_skill_timer_inquire_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///1bytes 功能表
  public var funcTable: UInt32 = 0

  ///1bytes 提醒支持最大数量
  public var timerSupportMax: UInt32 = 0

  ///定时器列表
  public var items: [skill_timer_item] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_skill_control_template_operate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///控制类型
  public var controlType: skill_control_type = .skillControlStart

  ///专用模板
  public var templateType: skill_template_type = .templateTypeStopwatch

  ///模版数据
  public var templateData: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct skill_naptimer_item: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var index: UInt32 = 0

  public var naptimerSec: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_skill_naptimer_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///定时器操作
  public var naptimerOperate: skill_naptimer_operate = .naptimerInsert

  ///定时器编号
  public var index: UInt32 = 0

  ///定时时间 单位秒
  public var naptimerSec: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_skill_naptimer_inquire_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///1bytes 功能表
  public var funcTable: UInt32 = 0

  ///1bytes 提醒支持最大数量
  public var naptimerSupportMax: UInt32 = 0

  ///定时器列表
  public var items: [skill_naptimer_item] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct skill_weather_future_item: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 天气类型
  public var weatherType: weather_type = .tornado

  ///1bytes 最大温度
  public var maxTemp: Int32 = 0

  ///1bytes 最小温度
  public var minTemp: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct skill_weather_hour_weather_item: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 天气类型
  public var weatherType: weather_type = .tornado

  ///1bytes 温度
  public var temperature: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct skill_weather_detail_data_item: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///最新同步
  public var year: UInt32 = 0

  /// 月份
  public var month: UInt32 = 0

  public var day: UInt32 = 0

  ///时
  public var hour: UInt32 = 0

  ///分
  public var min: UInt32 = 0

  ///1bytes 星期  0x00无效 0x01~0x07:星期一~星期日
  public var week: UInt32 = 0

  /// 天气类型
  public var weatherType: weather_type = .tornado

  ///1bytes 当前的温度
  public var curTemp: Int32 = 0

  ///1bytes 最大温度
  public var curMaxTemp: Int32 = 0

  ///1bytes 最小温度
  public var curMinTemp: Int32 = 0

  ///max:60 城市名称
  public var cityName: Data = Data()

  ///最近七天天气
  public var futureItems: [skill_weather_future_item] = []

  ///max:48 实时天气数据
  public var hoursWeatherItems: [skill_weather_hour_weather_item] = []

  ///温度单位，0：摄氏度，1：华氏度
  public var tempUnit: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_skill_weather_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  public var detailDataItem: skill_weather_detail_data_item {
    get {return _detailDataItem ?? skill_weather_detail_data_item()}
    set {_detailDataItem = newValue}
  }
  /// Returns true if `detailDataItem` has been explicitly set.
  public var hasDetailDataItem: Bool {return self._detailDataItem != nil}
  /// Clears the value of `detailDataItem`. Subsequent reads from it will return its default value.
  public mutating func clearDetailDataItem() {self._detailDataItem = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _detailDataItem: skill_weather_detail_data_item? = nil
}

public struct protocol_skill_weather_inquire_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///1bytes 功能表
  public var funcTable: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_skill_music_status_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///控制类型
  public var controlType: skill_music_type = .skillMusicPlayed

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct skill_phone_call_contact: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var contactName: Data = Data()

  public var phoneNum: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_skill_phone_call_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///联系人信息
  public var callContact: skill_phone_call_contact {
    get {return _callContact ?? skill_phone_call_contact()}
    set {_callContact = newValue}
  }
  /// Returns true if `callContact` has been explicitly set.
  public var hasCallContact: Bool {return self._callContact != nil}
  /// Clears the value of `callContact`. Subsequent reads from it will return its default value.
  public mutating func clearCallContact() {self._callContact = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _callContact: skill_phone_call_contact? = nil
}

public struct protocol_skill_app_jump_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///跳转应用类型
  public var appType: app_list = .activity

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension protocol_skill_control_exercise_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_skill_control_exercise_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "sport_type"),
    3: .standard(proto: "control_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.sportType) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.controlType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.sportType != .orun {
      try visitor.visitSingularEnumField(value: self.sportType, fieldNumber: 2)
    }
    if self.controlType != .skillControlStart {
      try visitor.visitSingularEnumField(value: self.controlType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_skill_control_exercise_operate, rhs: protocol_skill_control_exercise_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.sportType != rhs.sportType {return false}
    if lhs.controlType != rhs.controlType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension skill_timer_item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "skill_timer_item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .standard(proto: "timer_sec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.timerSec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    if self.timerSec != 0 {
      try visitor.visitSingularUInt32Field(value: self.timerSec, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: skill_timer_item, rhs: skill_timer_item) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.timerSec != rhs.timerSec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_skill_timer_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_skill_timer_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "timer_operate"),
    3: .same(proto: "index"),
    4: .standard(proto: "timer_sec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.timerOperate) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.timerSec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.timerOperate != .timerInsertTimer {
      try visitor.visitSingularEnumField(value: self.timerOperate, fieldNumber: 2)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 3)
    }
    if self.timerSec != 0 {
      try visitor.visitSingularUInt32Field(value: self.timerSec, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_skill_timer_operate, rhs: protocol_skill_timer_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.timerOperate != rhs.timerOperate {return false}
    if lhs.index != rhs.index {return false}
    if lhs.timerSec != rhs.timerSec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_skill_timer_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_skill_timer_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "func_table"),
    3: .standard(proto: "timer_support_max"),
    4: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.funcTable) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.timerSupportMax) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.funcTable != 0 {
      try visitor.visitSingularUInt32Field(value: self.funcTable, fieldNumber: 2)
    }
    if self.timerSupportMax != 0 {
      try visitor.visitSingularUInt32Field(value: self.timerSupportMax, fieldNumber: 3)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_skill_timer_inquire_reply, rhs: protocol_skill_timer_inquire_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.funcTable != rhs.funcTable {return false}
    if lhs.timerSupportMax != rhs.timerSupportMax {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_skill_control_template_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_skill_control_template_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "control_type"),
    3: .standard(proto: "template_type"),
    4: .standard(proto: "template_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.controlType) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.templateType) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.templateData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.controlType != .skillControlStart {
      try visitor.visitSingularEnumField(value: self.controlType, fieldNumber: 2)
    }
    if self.templateType != .templateTypeStopwatch {
      try visitor.visitSingularEnumField(value: self.templateType, fieldNumber: 3)
    }
    if !self.templateData.isEmpty {
      try visitor.visitSingularBytesField(value: self.templateData, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_skill_control_template_operate, rhs: protocol_skill_control_template_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.controlType != rhs.controlType {return false}
    if lhs.templateType != rhs.templateType {return false}
    if lhs.templateData != rhs.templateData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension skill_naptimer_item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "skill_naptimer_item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .standard(proto: "naptimer_sec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.naptimerSec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    if self.naptimerSec != 0 {
      try visitor.visitSingularUInt32Field(value: self.naptimerSec, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: skill_naptimer_item, rhs: skill_naptimer_item) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.naptimerSec != rhs.naptimerSec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_skill_naptimer_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_skill_naptimer_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "naptimer_operate"),
    3: .same(proto: "index"),
    4: .standard(proto: "naptimer_sec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.naptimerOperate) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.naptimerSec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.naptimerOperate != .naptimerInsert {
      try visitor.visitSingularEnumField(value: self.naptimerOperate, fieldNumber: 2)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 3)
    }
    if self.naptimerSec != 0 {
      try visitor.visitSingularUInt32Field(value: self.naptimerSec, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_skill_naptimer_operate, rhs: protocol_skill_naptimer_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.naptimerOperate != rhs.naptimerOperate {return false}
    if lhs.index != rhs.index {return false}
    if lhs.naptimerSec != rhs.naptimerSec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_skill_naptimer_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_skill_naptimer_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "func_table"),
    3: .standard(proto: "naptimer_support_max"),
    4: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.funcTable) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.naptimerSupportMax) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.funcTable != 0 {
      try visitor.visitSingularUInt32Field(value: self.funcTable, fieldNumber: 2)
    }
    if self.naptimerSupportMax != 0 {
      try visitor.visitSingularUInt32Field(value: self.naptimerSupportMax, fieldNumber: 3)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_skill_naptimer_inquire_reply, rhs: protocol_skill_naptimer_inquire_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.funcTable != rhs.funcTable {return false}
    if lhs.naptimerSupportMax != rhs.naptimerSupportMax {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension skill_weather_future_item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "skill_weather_future_item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "weather_type"),
    2: .standard(proto: "max_temp"),
    3: .standard(proto: "min_temp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.weatherType) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxTemp) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.minTemp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.weatherType != .tornado {
      try visitor.visitSingularEnumField(value: self.weatherType, fieldNumber: 1)
    }
    if self.maxTemp != 0 {
      try visitor.visitSingularInt32Field(value: self.maxTemp, fieldNumber: 2)
    }
    if self.minTemp != 0 {
      try visitor.visitSingularInt32Field(value: self.minTemp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: skill_weather_future_item, rhs: skill_weather_future_item) -> Bool {
    if lhs.weatherType != rhs.weatherType {return false}
    if lhs.maxTemp != rhs.maxTemp {return false}
    if lhs.minTemp != rhs.minTemp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension skill_weather_hour_weather_item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "skill_weather_hour_weather_item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "weather_type"),
    2: .same(proto: "temperature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.weatherType) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.temperature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.weatherType != .tornado {
      try visitor.visitSingularEnumField(value: self.weatherType, fieldNumber: 1)
    }
    if self.temperature != 0 {
      try visitor.visitSingularInt32Field(value: self.temperature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: skill_weather_hour_weather_item, rhs: skill_weather_hour_weather_item) -> Bool {
    if lhs.weatherType != rhs.weatherType {return false}
    if lhs.temperature != rhs.temperature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension skill_weather_detail_data_item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "skill_weather_detail_data_item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "year"),
    2: .same(proto: "month"),
    3: .same(proto: "day"),
    4: .same(proto: "hour"),
    5: .same(proto: "min"),
    6: .same(proto: "week"),
    7: .standard(proto: "weather_type"),
    8: .standard(proto: "cur_temp"),
    9: .standard(proto: "cur_max_temp"),
    10: .standard(proto: "cur_min_temp"),
    11: .standard(proto: "city_name"),
    12: .standard(proto: "future_items"),
    13: .standard(proto: "hours_weather_items"),
    14: .standard(proto: "temp_unit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.year) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.month) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.day) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.hour) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.min) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.week) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.weatherType) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.curTemp) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.curMaxTemp) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.curMinTemp) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self.cityName) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.futureItems) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.hoursWeatherItems) }()
      case 14: try { try decoder.decodeSingularUInt32Field(value: &self.tempUnit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.year != 0 {
      try visitor.visitSingularUInt32Field(value: self.year, fieldNumber: 1)
    }
    if self.month != 0 {
      try visitor.visitSingularUInt32Field(value: self.month, fieldNumber: 2)
    }
    if self.day != 0 {
      try visitor.visitSingularUInt32Field(value: self.day, fieldNumber: 3)
    }
    if self.hour != 0 {
      try visitor.visitSingularUInt32Field(value: self.hour, fieldNumber: 4)
    }
    if self.min != 0 {
      try visitor.visitSingularUInt32Field(value: self.min, fieldNumber: 5)
    }
    if self.week != 0 {
      try visitor.visitSingularUInt32Field(value: self.week, fieldNumber: 6)
    }
    if self.weatherType != .tornado {
      try visitor.visitSingularEnumField(value: self.weatherType, fieldNumber: 7)
    }
    if self.curTemp != 0 {
      try visitor.visitSingularInt32Field(value: self.curTemp, fieldNumber: 8)
    }
    if self.curMaxTemp != 0 {
      try visitor.visitSingularInt32Field(value: self.curMaxTemp, fieldNumber: 9)
    }
    if self.curMinTemp != 0 {
      try visitor.visitSingularInt32Field(value: self.curMinTemp, fieldNumber: 10)
    }
    if !self.cityName.isEmpty {
      try visitor.visitSingularBytesField(value: self.cityName, fieldNumber: 11)
    }
    if !self.futureItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.futureItems, fieldNumber: 12)
    }
    if !self.hoursWeatherItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hoursWeatherItems, fieldNumber: 13)
    }
    if self.tempUnit != 0 {
      try visitor.visitSingularUInt32Field(value: self.tempUnit, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: skill_weather_detail_data_item, rhs: skill_weather_detail_data_item) -> Bool {
    if lhs.year != rhs.year {return false}
    if lhs.month != rhs.month {return false}
    if lhs.day != rhs.day {return false}
    if lhs.hour != rhs.hour {return false}
    if lhs.min != rhs.min {return false}
    if lhs.week != rhs.week {return false}
    if lhs.weatherType != rhs.weatherType {return false}
    if lhs.curTemp != rhs.curTemp {return false}
    if lhs.curMaxTemp != rhs.curMaxTemp {return false}
    if lhs.curMinTemp != rhs.curMinTemp {return false}
    if lhs.cityName != rhs.cityName {return false}
    if lhs.futureItems != rhs.futureItems {return false}
    if lhs.hoursWeatherItems != rhs.hoursWeatherItems {return false}
    if lhs.tempUnit != rhs.tempUnit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_skill_weather_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_skill_weather_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "detail_data_item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._detailDataItem) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    try { if let v = self._detailDataItem {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_skill_weather_operate, rhs: protocol_skill_weather_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs._detailDataItem != rhs._detailDataItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_skill_weather_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_skill_weather_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "func_table"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.funcTable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.funcTable != 0 {
      try visitor.visitSingularUInt32Field(value: self.funcTable, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_skill_weather_inquire_reply, rhs: protocol_skill_weather_inquire_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.funcTable != rhs.funcTable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_skill_music_status_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_skill_music_status_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "control_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.controlType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.controlType != .skillMusicPlayed {
      try visitor.visitSingularEnumField(value: self.controlType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_skill_music_status_operate, rhs: protocol_skill_music_status_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.controlType != rhs.controlType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension skill_phone_call_contact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "skill_phone_call_contact"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contact_name"),
    2: .standard(proto: "phone_num"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.contactName) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.phoneNum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contactName.isEmpty {
      try visitor.visitSingularBytesField(value: self.contactName, fieldNumber: 1)
    }
    if !self.phoneNum.isEmpty {
      try visitor.visitSingularBytesField(value: self.phoneNum, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: skill_phone_call_contact, rhs: skill_phone_call_contact) -> Bool {
    if lhs.contactName != rhs.contactName {return false}
    if lhs.phoneNum != rhs.phoneNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_skill_phone_call_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_skill_phone_call_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "call_contact"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._callContact) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    try { if let v = self._callContact {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_skill_phone_call_operate, rhs: protocol_skill_phone_call_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs._callContact != rhs._callContact {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_skill_app_jump_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_skill_app_jump_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "app_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.appType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.appType != .activity {
      try visitor.visitSingularEnumField(value: self.appType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_skill_app_jump_operate, rhs: protocol_skill_app_jump_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.appType != rhs.appType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
