// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: deviceinfo.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct protocol_device_batt_info: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///2bytes
  public var voltage: UInt32 = 0

  ///1bytes 电池状态
  public var status: Batt_status = .normal

  ///1bytes
  public var battLevel: UInt32 = 0

  ///2bytes
  public var lastChargingYear: UInt32 = 0

  ///1bytes
  public var lastChargingMonth: UInt32 = 0

  ///1bytes
  public var lastChargingDay: UInt32 = 0

  ///1bytes
  public var lastChargingHour: UInt32 = 0

  ///1bytes
  public var lastChargingMinute: UInt32 = 0

  ///1bytes
  public var lastChargingSecond: UInt32 = 0

  /// 1bytes 0x01:模式
  public var mode: Batt_mode = .invalidMode

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_bt_name: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///是否支持bt，支持则可以获取bt蓝牙名，ios需要
  public var isSupport: Bool = false

  ///max:16bytes
  public var btName: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct device_size_info: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///2bytes 宽
  public var width: UInt32 = 0

  ///2bytes 高
  public var height: UInt32 = 0

  ///2bytes 圆角角度
  public var angle: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct hardware_support: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///心率传感器
  public var heartrateHardware: Bool = false

  ///acc传感器
  public var accHardware: Bool = false

  ///陀螺仪传感器
  public var gyroHardware: Bool = false

  ///按键
  public var buttonHardware: Bool = false

  ///屏幕
  public var lcdHardware: Bool = false

  ///tp
  public var tpHardware: Bool = false

  ///motor
  public var motorHardware: Bool = false

  ///麦克风
  public var micHardware: Bool = false

  ///喇叭
  public var speakHardware: Bool = false

  ///gps
  public var gpsHardware: Bool = false

  ///nor_flash
  public var norflashHardware: Bool = false

  ///nand_flash
  public var nandflashHardware: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct device_sn_info: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///产品系列标识
  public var productID: UInt32 = 0

  ///工厂标识
  public var factoryID: UInt32 = 0

  ///客户标识
  public var customerID: UInt32 = 0

  ///生产年月日
  public var productionDate: UInt32 = 0

  ///批次号
  public var batchNum: UInt32 = 0

  ///顺序编号
  public var serialNum: UInt32 = 0

  ///颜色代号
  public var colorCode: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct device_voice_assistant: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 固件主版本号
  public var fwMajorVersion: UInt32 = 0

  /// 固件次版本号
  public var fwMinorVersion: UInt32 = 0

  /// 固件语言类型
  public var fwType: UInt32 = 0

  /// 网络主版本号
  public var nwMajorVersion: UInt32 = 0

  /// 网络次版本号
  public var nwMinorrVersion: UInt32 = 0

  /// 网络语言类型
  public var nwType: UInt32 = 0

  ///当前语言
  public var currentLanguage: UInt32 = 0

  ///是否切换语言  0是切换 1是未切换
  public var switchLanguage: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_device_info: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///2bytes 设备id
  public var deviceID: UInt32 {
    get {return _storage._deviceID}
    set {_uniqueStorage()._deviceID = newValue}
  }

  ///1bytes 固件主版本号
  public var majorVersion: UInt32 {
    get {return _storage._majorVersion}
    set {_uniqueStorage()._majorVersion = newValue}
  }

  ///1bytes 固件次版本号
  public var minorVersion: UInt32 {
    get {return _storage._minorVersion}
    set {_uniqueStorage()._minorVersion = newValue}
  }

  ///1bytes 固件小版本号
  public var microVersion: UInt32 {
    get {return _storage._microVersion}
    set {_uniqueStorage()._microVersion = newValue}
  }

  ///1bytes 绑定状态
  public var pairFlag: UInt32 {
    get {return _storage._pairFlag}
    set {_uniqueStorage()._pairFlag = newValue}
  }

  ///1bytes 手表的平台
  public var platform: Platform {
    get {return _storage._platform}
    set {_uniqueStorage()._platform = newValue}
  }

  ///1bytes 设备形状
  public var shape: Shape {
    get {return _storage._shape}
    set {_uniqueStorage()._shape = newValue}
  }

  ///设备类型
  public var devType: Dev_type {
    get {return _storage._devType}
    set {_uniqueStorage()._devType = newValue}
  }

  ///max:6bytes ble蓝牙地址
  public var macAddr: Data {
    get {return _storage._macAddr}
    set {_uniqueStorage()._macAddr = newValue}
  }

  ///max:6bytes bt蓝牙地址
  public var btAddr: Data {
    get {return _storage._btAddr}
    set {_uniqueStorage()._btAddr = newValue}
  }

  public var battInfo: protocol_device_batt_info {
    get {return _storage._battInfo ?? protocol_device_batt_info()}
    set {_uniqueStorage()._battInfo = newValue}
  }
  /// Returns true if `battInfo` has been explicitly set.
  public var hasBattInfo: Bool {return _storage._battInfo != nil}
  /// Clears the value of `battInfo`. Subsequent reads from it will return its default value.
  public mutating func clearBattInfo() {_uniqueStorage()._battInfo = nil}

  public var btName: protocol_bt_name {
    get {return _storage._btName ?? protocol_bt_name()}
    set {_uniqueStorage()._btName = newValue}
  }
  /// Returns true if `btName` has been explicitly set.
  public var hasBtName: Bool {return _storage._btName != nil}
  /// Clears the value of `btName`. Subsequent reads from it will return its default value.
  public mutating func clearBtName() {_uniqueStorage()._btName = nil}

  ///1bytes 字库主版本号
  public var fontMajorVersion: UInt32 {
    get {return _storage._fontMajorVersion}
    set {_uniqueStorage()._fontMajorVersion = newValue}
  }

  ///1bytes 字库次版本号
  public var fontMinorVersion: UInt32 {
    get {return _storage._fontMinorVersion}
    set {_uniqueStorage()._fontMinorVersion = newValue}
  }

  ///1bytes 字库小版本号
  public var fontMicroVersion: UInt32 {
    get {return _storage._fontMicroVersion}
    set {_uniqueStorage()._fontMicroVersion = newValue}
  }

  ///1bytes 重启标志
  public var rebootFlag: UInt32 {
    get {return _storage._rebootFlag}
    set {_uniqueStorage()._rebootFlag = newValue}
  }

  ///硬件支持
  public var hwSupport: hardware_support {
    get {return _storage._hwSupport ?? hardware_support()}
    set {_uniqueStorage()._hwSupport = newValue}
  }
  /// Returns true if `hwSupport` has been explicitly set.
  public var hasHwSupport: Bool {return _storage._hwSupport != nil}
  /// Clears the value of `hwSupport`. Subsequent reads from it will return its default value.
  public mutating func clearHwSupport() {_uniqueStorage()._hwSupport = nil}

  ///gps芯片型号
  public var gpsSocName: String {
    get {return _storage._gpsSocName}
    set {_uniqueStorage()._gpsSocName = newValue}
  }

  ///设备规格大小
  public var sizeInfo: device_size_info {
    get {return _storage._sizeInfo ?? device_size_info()}
    set {_uniqueStorage()._sizeInfo = newValue}
  }
  /// Returns true if `sizeInfo` has been explicitly set.
  public var hasSizeInfo: Bool {return _storage._sizeInfo != nil}
  /// Clears the value of `sizeInfo`. Subsequent reads from it will return its default value.
  public mutating func clearSizeInfo() {_uniqueStorage()._sizeInfo = nil}

  ///1bytes 恢复模式标志
  public var isRecoveryMode: Bool {
    get {return _storage._isRecoveryMode}
    set {_uniqueStorage()._isRecoveryMode = newValue}
  }

  ///1bytes 设备颜色 深锖（SN代号：A）、钛银（SN代号：B）、香槟金（SN代号：C）、玫瑰粉（SN代号：D）、茉莉红（SN代号：E）、黛紫（SN代号：F）
  public var deviceColor: UInt32 {
    get {return _storage._deviceColor}
    set {_uniqueStorage()._deviceColor = newValue}
  }

  ///1bytes 照片表盘支持相片个数
  public var platePhotoPicSupportNum: UInt32 {
    get {return _storage._platePhotoPicSupportNum}
    set {_uniqueStorage()._platePhotoPicSupportNum = newValue}
  }

  ///SN 码
  public var snInfo: device_sn_info {
    get {return _storage._snInfo ?? device_sn_info()}
    set {_uniqueStorage()._snInfo = newValue}
  }
  /// Returns true if `snInfo` has been explicitly set.
  public var hasSnInfo: Bool {return _storage._snInfo != nil}
  /// Clears the value of `snInfo`. Subsequent reads from it will return its default value.
  public mutating func clearSnInfo() {_uniqueStorage()._snInfo = nil}

  ///语音助手设备
  public var voiceAssistant: device_voice_assistant {
    get {return _storage._voiceAssistant ?? device_voice_assistant()}
    set {_uniqueStorage()._voiceAssistant = newValue}
  }
  /// Returns true if `voiceAssistant` has been explicitly set.
  public var hasVoiceAssistant: Bool {return _storage._voiceAssistant != nil}
  /// Clears the value of `voiceAssistant`. Subsequent reads from it will return its default value.
  public mutating func clearVoiceAssistant() {_uniqueStorage()._voiceAssistant = nil}

  ///是否开始心率推送
  public var heartratePush: Bool {
    get {return _storage._heartratePush}
    set {_uniqueStorage()._heartratePush = newValue}
  }

  ///扳手模式（0:正常 1:设备进入扳手界面(软件或硬件复位导致)）
  public var isWrenchMode: Bool {
    get {return _storage._isWrenchMode}
    set {_uniqueStorage()._isWrenchMode = newValue}
  }

  ///绑定方式支持
  public var bind: bind_method_support {
    get {return _storage._bind}
    set {_uniqueStorage()._bind = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension protocol_device_batt_info: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_device_batt_info"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "voltage"),
    2: .same(proto: "status"),
    3: .standard(proto: "batt_level"),
    4: .standard(proto: "last_charging_year"),
    5: .standard(proto: "last_charging_month"),
    6: .standard(proto: "last_charging_day"),
    7: .standard(proto: "last_charging_hour"),
    8: .standard(proto: "last_charging_minute"),
    9: .standard(proto: "last_charging_second"),
    10: .same(proto: "mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.voltage) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.battLevel) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.lastChargingYear) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.lastChargingMonth) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.lastChargingDay) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.lastChargingHour) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.lastChargingMinute) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.lastChargingSecond) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.voltage != 0 {
      try visitor.visitSingularUInt32Field(value: self.voltage, fieldNumber: 1)
    }
    if self.status != .normal {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if self.battLevel != 0 {
      try visitor.visitSingularUInt32Field(value: self.battLevel, fieldNumber: 3)
    }
    if self.lastChargingYear != 0 {
      try visitor.visitSingularUInt32Field(value: self.lastChargingYear, fieldNumber: 4)
    }
    if self.lastChargingMonth != 0 {
      try visitor.visitSingularUInt32Field(value: self.lastChargingMonth, fieldNumber: 5)
    }
    if self.lastChargingDay != 0 {
      try visitor.visitSingularUInt32Field(value: self.lastChargingDay, fieldNumber: 6)
    }
    if self.lastChargingHour != 0 {
      try visitor.visitSingularUInt32Field(value: self.lastChargingHour, fieldNumber: 7)
    }
    if self.lastChargingMinute != 0 {
      try visitor.visitSingularUInt32Field(value: self.lastChargingMinute, fieldNumber: 8)
    }
    if self.lastChargingSecond != 0 {
      try visitor.visitSingularUInt32Field(value: self.lastChargingSecond, fieldNumber: 9)
    }
    if self.mode != .invalidMode {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_device_batt_info, rhs: protocol_device_batt_info) -> Bool {
    if lhs.voltage != rhs.voltage {return false}
    if lhs.status != rhs.status {return false}
    if lhs.battLevel != rhs.battLevel {return false}
    if lhs.lastChargingYear != rhs.lastChargingYear {return false}
    if lhs.lastChargingMonth != rhs.lastChargingMonth {return false}
    if lhs.lastChargingDay != rhs.lastChargingDay {return false}
    if lhs.lastChargingHour != rhs.lastChargingHour {return false}
    if lhs.lastChargingMinute != rhs.lastChargingMinute {return false}
    if lhs.lastChargingSecond != rhs.lastChargingSecond {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_bt_name: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_bt_name"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_support"),
    2: .standard(proto: "bt_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isSupport) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.btName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isSupport != false {
      try visitor.visitSingularBoolField(value: self.isSupport, fieldNumber: 1)
    }
    if !self.btName.isEmpty {
      try visitor.visitSingularBytesField(value: self.btName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_bt_name, rhs: protocol_bt_name) -> Bool {
    if lhs.isSupport != rhs.isSupport {return false}
    if lhs.btName != rhs.btName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension device_size_info: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "device_size_info"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .same(proto: "angle"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.angle) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 2)
    }
    if self.angle != 0 {
      try visitor.visitSingularUInt32Field(value: self.angle, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: device_size_info, rhs: device_size_info) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.angle != rhs.angle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension hardware_support: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "hardware_support"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "heartrate_hardware"),
    2: .standard(proto: "acc_hardware"),
    3: .standard(proto: "gyro_hardware"),
    4: .standard(proto: "button_hardware"),
    5: .standard(proto: "lcd_hardware"),
    6: .standard(proto: "tp_hardware"),
    7: .standard(proto: "motor_hardware"),
    8: .standard(proto: "mic_hardware"),
    9: .standard(proto: "speak_hardware"),
    10: .standard(proto: "gps_hardware"),
    11: .standard(proto: "norflash_hardware"),
    12: .standard(proto: "nandflash_hardware"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.heartrateHardware) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.accHardware) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.gyroHardware) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.buttonHardware) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.lcdHardware) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.tpHardware) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.motorHardware) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.micHardware) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.speakHardware) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.gpsHardware) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.norflashHardware) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.nandflashHardware) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.heartrateHardware != false {
      try visitor.visitSingularBoolField(value: self.heartrateHardware, fieldNumber: 1)
    }
    if self.accHardware != false {
      try visitor.visitSingularBoolField(value: self.accHardware, fieldNumber: 2)
    }
    if self.gyroHardware != false {
      try visitor.visitSingularBoolField(value: self.gyroHardware, fieldNumber: 3)
    }
    if self.buttonHardware != false {
      try visitor.visitSingularBoolField(value: self.buttonHardware, fieldNumber: 4)
    }
    if self.lcdHardware != false {
      try visitor.visitSingularBoolField(value: self.lcdHardware, fieldNumber: 5)
    }
    if self.tpHardware != false {
      try visitor.visitSingularBoolField(value: self.tpHardware, fieldNumber: 6)
    }
    if self.motorHardware != false {
      try visitor.visitSingularBoolField(value: self.motorHardware, fieldNumber: 7)
    }
    if self.micHardware != false {
      try visitor.visitSingularBoolField(value: self.micHardware, fieldNumber: 8)
    }
    if self.speakHardware != false {
      try visitor.visitSingularBoolField(value: self.speakHardware, fieldNumber: 9)
    }
    if self.gpsHardware != false {
      try visitor.visitSingularBoolField(value: self.gpsHardware, fieldNumber: 10)
    }
    if self.norflashHardware != false {
      try visitor.visitSingularBoolField(value: self.norflashHardware, fieldNumber: 11)
    }
    if self.nandflashHardware != false {
      try visitor.visitSingularBoolField(value: self.nandflashHardware, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: hardware_support, rhs: hardware_support) -> Bool {
    if lhs.heartrateHardware != rhs.heartrateHardware {return false}
    if lhs.accHardware != rhs.accHardware {return false}
    if lhs.gyroHardware != rhs.gyroHardware {return false}
    if lhs.buttonHardware != rhs.buttonHardware {return false}
    if lhs.lcdHardware != rhs.lcdHardware {return false}
    if lhs.tpHardware != rhs.tpHardware {return false}
    if lhs.motorHardware != rhs.motorHardware {return false}
    if lhs.micHardware != rhs.micHardware {return false}
    if lhs.speakHardware != rhs.speakHardware {return false}
    if lhs.gpsHardware != rhs.gpsHardware {return false}
    if lhs.norflashHardware != rhs.norflashHardware {return false}
    if lhs.nandflashHardware != rhs.nandflashHardware {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension device_sn_info: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "device_sn_info"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "product_id"),
    2: .standard(proto: "factory_id"),
    3: .standard(proto: "customer_id"),
    4: .standard(proto: "production_date"),
    5: .standard(proto: "batch_num"),
    6: .standard(proto: "serial_num"),
    7: .standard(proto: "color_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.productID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.factoryID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.customerID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.productionDate) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.batchNum) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.serialNum) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.colorCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.productID != 0 {
      try visitor.visitSingularUInt32Field(value: self.productID, fieldNumber: 1)
    }
    if self.factoryID != 0 {
      try visitor.visitSingularUInt32Field(value: self.factoryID, fieldNumber: 2)
    }
    if self.customerID != 0 {
      try visitor.visitSingularUInt32Field(value: self.customerID, fieldNumber: 3)
    }
    if self.productionDate != 0 {
      try visitor.visitSingularUInt32Field(value: self.productionDate, fieldNumber: 4)
    }
    if self.batchNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.batchNum, fieldNumber: 5)
    }
    if self.serialNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.serialNum, fieldNumber: 6)
    }
    if self.colorCode != 0 {
      try visitor.visitSingularUInt32Field(value: self.colorCode, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: device_sn_info, rhs: device_sn_info) -> Bool {
    if lhs.productID != rhs.productID {return false}
    if lhs.factoryID != rhs.factoryID {return false}
    if lhs.customerID != rhs.customerID {return false}
    if lhs.productionDate != rhs.productionDate {return false}
    if lhs.batchNum != rhs.batchNum {return false}
    if lhs.serialNum != rhs.serialNum {return false}
    if lhs.colorCode != rhs.colorCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension device_voice_assistant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "device_voice_assistant"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fw_major_version"),
    2: .standard(proto: "fw_minor_version"),
    3: .standard(proto: "fw_type"),
    4: .standard(proto: "nw_major_version"),
    5: .standard(proto: "nw_minorr_version"),
    6: .standard(proto: "nw_type"),
    7: .standard(proto: "current_language"),
    8: .standard(proto: "switch_language"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.fwMajorVersion) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.fwMinorVersion) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.fwType) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.nwMajorVersion) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.nwMinorrVersion) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.nwType) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.currentLanguage) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.switchLanguage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fwMajorVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.fwMajorVersion, fieldNumber: 1)
    }
    if self.fwMinorVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.fwMinorVersion, fieldNumber: 2)
    }
    if self.fwType != 0 {
      try visitor.visitSingularUInt32Field(value: self.fwType, fieldNumber: 3)
    }
    if self.nwMajorVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.nwMajorVersion, fieldNumber: 4)
    }
    if self.nwMinorrVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.nwMinorrVersion, fieldNumber: 5)
    }
    if self.nwType != 0 {
      try visitor.visitSingularUInt32Field(value: self.nwType, fieldNumber: 6)
    }
    if self.currentLanguage != 0 {
      try visitor.visitSingularUInt32Field(value: self.currentLanguage, fieldNumber: 7)
    }
    if self.switchLanguage != 0 {
      try visitor.visitSingularUInt32Field(value: self.switchLanguage, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: device_voice_assistant, rhs: device_voice_assistant) -> Bool {
    if lhs.fwMajorVersion != rhs.fwMajorVersion {return false}
    if lhs.fwMinorVersion != rhs.fwMinorVersion {return false}
    if lhs.fwType != rhs.fwType {return false}
    if lhs.nwMajorVersion != rhs.nwMajorVersion {return false}
    if lhs.nwMinorrVersion != rhs.nwMinorrVersion {return false}
    if lhs.nwType != rhs.nwType {return false}
    if lhs.currentLanguage != rhs.currentLanguage {return false}
    if lhs.switchLanguage != rhs.switchLanguage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_device_info: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_device_info"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
    2: .standard(proto: "major_version"),
    3: .standard(proto: "minor_version"),
    4: .standard(proto: "micro_version"),
    5: .standard(proto: "pair_flag"),
    6: .same(proto: "platform"),
    7: .same(proto: "shape"),
    8: .standard(proto: "dev_type"),
    9: .standard(proto: "mac_addr"),
    10: .standard(proto: "bt_addr"),
    11: .standard(proto: "batt_info"),
    12: .standard(proto: "bt_name"),
    13: .standard(proto: "font_major_version"),
    14: .standard(proto: "font_minor_version"),
    15: .standard(proto: "font_micro_version"),
    16: .standard(proto: "reboot_flag"),
    17: .standard(proto: "hw_support"),
    18: .standard(proto: "gps_soc_name"),
    19: .standard(proto: "size_info"),
    20: .standard(proto: "is_recovery_mode"),
    21: .standard(proto: "device_color"),
    22: .standard(proto: "plate_photo_pic_support_num"),
    23: .standard(proto: "sn_info"),
    24: .standard(proto: "voice_assistant"),
    25: .standard(proto: "heartrate_push"),
    26: .standard(proto: "is_wrench_mode"),
    27: .same(proto: "bind"),
  ]

  fileprivate class _StorageClass {
    var _deviceID: UInt32 = 0
    var _majorVersion: UInt32 = 0
    var _minorVersion: UInt32 = 0
    var _microVersion: UInt32 = 0
    var _pairFlag: UInt32 = 0
    var _platform: Platform = .jx3085CPlatform
    var _shape: Shape = .squareShape
    var _devType: Dev_type = .watchType
    var _macAddr: Data = Data()
    var _btAddr: Data = Data()
    var _battInfo: protocol_device_batt_info? = nil
    var _btName: protocol_bt_name? = nil
    var _fontMajorVersion: UInt32 = 0
    var _fontMinorVersion: UInt32 = 0
    var _fontMicroVersion: UInt32 = 0
    var _rebootFlag: UInt32 = 0
    var _hwSupport: hardware_support? = nil
    var _gpsSocName: String = String()
    var _sizeInfo: device_size_info? = nil
    var _isRecoveryMode: Bool = false
    var _deviceColor: UInt32 = 0
    var _platePhotoPicSupportNum: UInt32 = 0
    var _snInfo: device_sn_info? = nil
    var _voiceAssistant: device_voice_assistant? = nil
    var _heartratePush: Bool = false
    var _isWrenchMode: Bool = false
    var _bind: bind_method_support = .pairingCodeNormalSupport

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _deviceID = source._deviceID
      _majorVersion = source._majorVersion
      _minorVersion = source._minorVersion
      _microVersion = source._microVersion
      _pairFlag = source._pairFlag
      _platform = source._platform
      _shape = source._shape
      _devType = source._devType
      _macAddr = source._macAddr
      _btAddr = source._btAddr
      _battInfo = source._battInfo
      _btName = source._btName
      _fontMajorVersion = source._fontMajorVersion
      _fontMinorVersion = source._fontMinorVersion
      _fontMicroVersion = source._fontMicroVersion
      _rebootFlag = source._rebootFlag
      _hwSupport = source._hwSupport
      _gpsSocName = source._gpsSocName
      _sizeInfo = source._sizeInfo
      _isRecoveryMode = source._isRecoveryMode
      _deviceColor = source._deviceColor
      _platePhotoPicSupportNum = source._platePhotoPicSupportNum
      _snInfo = source._snInfo
      _voiceAssistant = source._voiceAssistant
      _heartratePush = source._heartratePush
      _isWrenchMode = source._isWrenchMode
      _bind = source._bind
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._deviceID) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._majorVersion) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._minorVersion) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._microVersion) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._pairFlag) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._platform) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._shape) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._devType) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._macAddr) }()
        case 10: try { try decoder.decodeSingularBytesField(value: &_storage._btAddr) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._battInfo) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._btName) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._fontMajorVersion) }()
        case 14: try { try decoder.decodeSingularUInt32Field(value: &_storage._fontMinorVersion) }()
        case 15: try { try decoder.decodeSingularUInt32Field(value: &_storage._fontMicroVersion) }()
        case 16: try { try decoder.decodeSingularUInt32Field(value: &_storage._rebootFlag) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._hwSupport) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._gpsSocName) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._sizeInfo) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._isRecoveryMode) }()
        case 21: try { try decoder.decodeSingularUInt32Field(value: &_storage._deviceColor) }()
        case 22: try { try decoder.decodeSingularUInt32Field(value: &_storage._platePhotoPicSupportNum) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._snInfo) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._voiceAssistant) }()
        case 25: try { try decoder.decodeSingularBoolField(value: &_storage._heartratePush) }()
        case 26: try { try decoder.decodeSingularBoolField(value: &_storage._isWrenchMode) }()
        case 27: try { try decoder.decodeSingularEnumField(value: &_storage._bind) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._deviceID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._deviceID, fieldNumber: 1)
      }
      if _storage._majorVersion != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._majorVersion, fieldNumber: 2)
      }
      if _storage._minorVersion != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._minorVersion, fieldNumber: 3)
      }
      if _storage._microVersion != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._microVersion, fieldNumber: 4)
      }
      if _storage._pairFlag != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._pairFlag, fieldNumber: 5)
      }
      if _storage._platform != .jx3085CPlatform {
        try visitor.visitSingularEnumField(value: _storage._platform, fieldNumber: 6)
      }
      if _storage._shape != .squareShape {
        try visitor.visitSingularEnumField(value: _storage._shape, fieldNumber: 7)
      }
      if _storage._devType != .watchType {
        try visitor.visitSingularEnumField(value: _storage._devType, fieldNumber: 8)
      }
      if !_storage._macAddr.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._macAddr, fieldNumber: 9)
      }
      if !_storage._btAddr.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._btAddr, fieldNumber: 10)
      }
      try { if let v = _storage._battInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._btName {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._fontMajorVersion != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._fontMajorVersion, fieldNumber: 13)
      }
      if _storage._fontMinorVersion != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._fontMinorVersion, fieldNumber: 14)
      }
      if _storage._fontMicroVersion != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._fontMicroVersion, fieldNumber: 15)
      }
      if _storage._rebootFlag != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._rebootFlag, fieldNumber: 16)
      }
      try { if let v = _storage._hwSupport {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if !_storage._gpsSocName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._gpsSocName, fieldNumber: 18)
      }
      try { if let v = _storage._sizeInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      if _storage._isRecoveryMode != false {
        try visitor.visitSingularBoolField(value: _storage._isRecoveryMode, fieldNumber: 20)
      }
      if _storage._deviceColor != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._deviceColor, fieldNumber: 21)
      }
      if _storage._platePhotoPicSupportNum != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._platePhotoPicSupportNum, fieldNumber: 22)
      }
      try { if let v = _storage._snInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._voiceAssistant {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      if _storage._heartratePush != false {
        try visitor.visitSingularBoolField(value: _storage._heartratePush, fieldNumber: 25)
      }
      if _storage._isWrenchMode != false {
        try visitor.visitSingularBoolField(value: _storage._isWrenchMode, fieldNumber: 26)
      }
      if _storage._bind != .pairingCodeNormalSupport {
        try visitor.visitSingularEnumField(value: _storage._bind, fieldNumber: 27)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_device_info, rhs: protocol_device_info) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._deviceID != rhs_storage._deviceID {return false}
        if _storage._majorVersion != rhs_storage._majorVersion {return false}
        if _storage._minorVersion != rhs_storage._minorVersion {return false}
        if _storage._microVersion != rhs_storage._microVersion {return false}
        if _storage._pairFlag != rhs_storage._pairFlag {return false}
        if _storage._platform != rhs_storage._platform {return false}
        if _storage._shape != rhs_storage._shape {return false}
        if _storage._devType != rhs_storage._devType {return false}
        if _storage._macAddr != rhs_storage._macAddr {return false}
        if _storage._btAddr != rhs_storage._btAddr {return false}
        if _storage._battInfo != rhs_storage._battInfo {return false}
        if _storage._btName != rhs_storage._btName {return false}
        if _storage._fontMajorVersion != rhs_storage._fontMajorVersion {return false}
        if _storage._fontMinorVersion != rhs_storage._fontMinorVersion {return false}
        if _storage._fontMicroVersion != rhs_storage._fontMicroVersion {return false}
        if _storage._rebootFlag != rhs_storage._rebootFlag {return false}
        if _storage._hwSupport != rhs_storage._hwSupport {return false}
        if _storage._gpsSocName != rhs_storage._gpsSocName {return false}
        if _storage._sizeInfo != rhs_storage._sizeInfo {return false}
        if _storage._isRecoveryMode != rhs_storage._isRecoveryMode {return false}
        if _storage._deviceColor != rhs_storage._deviceColor {return false}
        if _storage._platePhotoPicSupportNum != rhs_storage._platePhotoPicSupportNum {return false}
        if _storage._snInfo != rhs_storage._snInfo {return false}
        if _storage._voiceAssistant != rhs_storage._voiceAssistant {return false}
        if _storage._heartratePush != rhs_storage._heartratePush {return false}
        if _storage._isWrenchMode != rhs_storage._isWrenchMode {return false}
        if _storage._bind != rhs_storage._bind {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
