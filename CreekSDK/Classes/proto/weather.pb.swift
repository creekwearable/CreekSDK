// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: weather.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct protocol_weather_future_item: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 天气类型
  public var weatherType: weather_type = .tornado

  ///1bytes 最大温度
  public var maxTemp: Int32 = 0

  ///1bytes 最小温度
  public var minTemp: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_weather_hour_weather_item: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 天气类型
  public var weatherType: weather_type = .tornado

  ///1bytes 温度
  public var temperature: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///日出日落时间item
public struct protocol_weather_sunrise_item: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 日出
  public var sunriseHour: UInt32 = 0

  public var sunriseMin: UInt32 = 0

  ///1bytes 日落
  public var sunsetHour: UInt32 = 0

  public var sunsetMin: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///月出月落时间item
public struct protocol_weather_moon_item: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 月出
  public var moonriseHour: UInt32 = 0

  public var moonriseMin: UInt32 = 0

  ///1bytes 月落
  public var moonsetHour: UInt32 = 0

  public var moonsetMin: UInt32 = 0

  ///月相
  public var phase: moon_phase = .newMoon

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_weather_detail_data_item: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///最新同步 月份
  public var month: UInt32 {
    get {return _storage._month}
    set {_uniqueStorage()._month = newValue}
  }

  public var day: UInt32 {
    get {return _storage._day}
    set {_uniqueStorage()._day = newValue}
  }

  ///时
  public var hour: UInt32 {
    get {return _storage._hour}
    set {_uniqueStorage()._hour = newValue}
  }

  ///分
  public var min: UInt32 {
    get {return _storage._min}
    set {_uniqueStorage()._min = newValue}
  }

  ///1bytes 星期  0x00无效 0x01~0x07:星期一~星期日
  public var week: UInt32 {
    get {return _storage._week}
    set {_uniqueStorage()._week = newValue}
  }

  ///1bytes 天气类型
  public var weatherType: weather_type {
    get {return _storage._weatherType}
    set {_uniqueStorage()._weatherType = newValue}
  }

  ///1bytes 当前的温度
  public var curTemp: Int32 {
    get {return _storage._curTemp}
    set {_uniqueStorage()._curTemp = newValue}
  }

  ///1bytes 最大温度
  public var curMaxTemp: Int32 {
    get {return _storage._curMaxTemp}
    set {_uniqueStorage()._curMaxTemp = newValue}
  }

  ///1bytes 最小温度
  public var curMinTemp: Int32 {
    get {return _storage._curMinTemp}
    set {_uniqueStorage()._curMinTemp = newValue}
  }

  ///max:60 城市名称
  public var cityName: Data {
    get {return _storage._cityName}
    set {_uniqueStorage()._cityName = newValue}
  }

  ///max:48 实时天气数据，单位小时
  public var hoursWeatherItems: [protocol_weather_hour_weather_item] {
    get {return _storage._hoursWeatherItems}
    set {_uniqueStorage()._hoursWeatherItems = newValue}
  }

  ///1bytes 空气质量
  public var airQuality: UInt32 {
    get {return _storage._airQuality}
    set {_uniqueStorage()._airQuality = newValue}
  }

  ///2bytes  降水概率
  public var rainfallProbability: UInt32 {
    get {return _storage._rainfallProbability}
    set {_uniqueStorage()._rainfallProbability = newValue}
  }

  ///1bytes 湿度
  public var humidity: UInt32 {
    get {return _storage._humidity}
    set {_uniqueStorage()._humidity = newValue}
  }

  ///当前实时紫外线强度
  public var ultravioletIntensity: UInt32 {
    get {return _storage._ultravioletIntensity}
    set {_uniqueStorage()._ultravioletIntensity = newValue}
  }

  ///1bytes  风速，默认扩大100倍
  public var windSpeed: UInt32 {
    get {return _storage._windSpeed}
    set {_uniqueStorage()._windSpeed = newValue}
  }

  ///1bytes  风力等级
  public var windLevel: UInt32 {
    get {return _storage._windLevel}
    set {_uniqueStorage()._windLevel = newValue}
  }

  ///1bytes  风向
  public var windDirection: wind_direction_type {
    get {return _storage._windDirection}
    set {_uniqueStorage()._windDirection = newValue}
  }

  ///未来天气数据 暂定7天
  public var futureItems: [protocol_weather_future_item] {
    get {return _storage._futureItems}
    set {_uniqueStorage()._futureItems = newValue}
  }

  ///日出日落时间item
  public var sunriseItem: protocol_weather_sunrise_item {
    get {return _storage._sunriseItem ?? protocol_weather_sunrise_item()}
    set {_uniqueStorage()._sunriseItem = newValue}
  }
  /// Returns true if `sunriseItem` has been explicitly set.
  public var hasSunriseItem: Bool {return _storage._sunriseItem != nil}
  /// Clears the value of `sunriseItem`. Subsequent reads from it will return its default value.
  public mutating func clearSunriseItem() {_uniqueStorage()._sunriseItem = nil}

  ///是否定位城市
  public var location: Bool {
    get {return _storage._location}
    set {_uniqueStorage()._location = newValue}
  }

  ///气压，单位帕 数值*100
  public var atmosHpa: UInt32 {
    get {return _storage._atmosHpa}
    set {_uniqueStorage()._atmosHpa = newValue}
  }

  ///max:24 实时紫外线强度 24小时
  public var uvItems: [UInt32] {
    get {return _storage._uvItems}
    set {_uniqueStorage()._uvItems = newValue}
  }

  ///max：3 月出月落时间item 3天
  public var moonItem: [protocol_weather_moon_item] {
    get {return _storage._moonItem}
    set {_uniqueStorage()._moonItem = newValue}
  }

  ///max：3 日出日落时间item 3天
  public var sunriseItems: [protocol_weather_sunrise_item] {
    get {return _storage._sunriseItems}
    set {_uniqueStorage()._sunriseItems = newValue}
  }

  ///max:48 未来海平面大气压 数值*100
  public var atmosHpaItems: [UInt32] {
    get {return _storage._atmosHpaItems}
    set {_uniqueStorage()._atmosHpaItems = newValue}
  }

  ///4bytes 能见度 单位:米
  public var visibility: UInt32 {
    get {return _storage._visibility}
    set {_uniqueStorage()._visibility = newValue}
  }

  ///max:30 能见度等级文本
  public var visibilityLevel: Data {
    get {return _storage._visibilityLevel}
    set {_uniqueStorage()._visibilityLevel = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct protocol_weather_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///1bytes 天气功能 true 开启,false 关闭
  public var switchFlag: Bool = false

  public var detailDataItem: [protocol_weather_detail_data_item] = []

  ///当前位置 纬度 负数:S南纬  正数：N北纬 放大1000000倍
  public var latitude: Int32 = 0

  ///当前位置  经度 负数:W西经  正数：E东经 放大1000000倍
  public var longitude: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_weather_inquire_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 功能表
  public var funcTable: UInt32 = 0

  ///1bytes 天气详情支持最大数量
  public var weatherSupportMax: UInt32 = 0

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension protocol_weather_future_item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_weather_future_item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "weather_type"),
    2: .standard(proto: "max_temp"),
    3: .standard(proto: "min_temp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.weatherType) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxTemp) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.minTemp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.weatherType != .tornado {
      try visitor.visitSingularEnumField(value: self.weatherType, fieldNumber: 1)
    }
    if self.maxTemp != 0 {
      try visitor.visitSingularInt32Field(value: self.maxTemp, fieldNumber: 2)
    }
    if self.minTemp != 0 {
      try visitor.visitSingularInt32Field(value: self.minTemp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_weather_future_item, rhs: protocol_weather_future_item) -> Bool {
    if lhs.weatherType != rhs.weatherType {return false}
    if lhs.maxTemp != rhs.maxTemp {return false}
    if lhs.minTemp != rhs.minTemp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_weather_hour_weather_item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_weather_hour_weather_item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "weather_type"),
    2: .same(proto: "temperature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.weatherType) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.temperature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.weatherType != .tornado {
      try visitor.visitSingularEnumField(value: self.weatherType, fieldNumber: 1)
    }
    if self.temperature != 0 {
      try visitor.visitSingularInt32Field(value: self.temperature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_weather_hour_weather_item, rhs: protocol_weather_hour_weather_item) -> Bool {
    if lhs.weatherType != rhs.weatherType {return false}
    if lhs.temperature != rhs.temperature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_weather_sunrise_item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_weather_sunrise_item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sunrise_hour"),
    2: .standard(proto: "sunrise_min"),
    3: .standard(proto: "sunset_hour"),
    4: .standard(proto: "sunset_min"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.sunriseHour) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.sunriseMin) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.sunsetHour) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.sunsetMin) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sunriseHour != 0 {
      try visitor.visitSingularUInt32Field(value: self.sunriseHour, fieldNumber: 1)
    }
    if self.sunriseMin != 0 {
      try visitor.visitSingularUInt32Field(value: self.sunriseMin, fieldNumber: 2)
    }
    if self.sunsetHour != 0 {
      try visitor.visitSingularUInt32Field(value: self.sunsetHour, fieldNumber: 3)
    }
    if self.sunsetMin != 0 {
      try visitor.visitSingularUInt32Field(value: self.sunsetMin, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_weather_sunrise_item, rhs: protocol_weather_sunrise_item) -> Bool {
    if lhs.sunriseHour != rhs.sunriseHour {return false}
    if lhs.sunriseMin != rhs.sunriseMin {return false}
    if lhs.sunsetHour != rhs.sunsetHour {return false}
    if lhs.sunsetMin != rhs.sunsetMin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_weather_moon_item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_weather_moon_item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "moonrise_hour"),
    2: .standard(proto: "moonrise_min"),
    3: .standard(proto: "moonset_hour"),
    4: .standard(proto: "moonset_min"),
    5: .same(proto: "phase"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.moonriseHour) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.moonriseMin) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.moonsetHour) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.moonsetMin) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.phase) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.moonriseHour != 0 {
      try visitor.visitSingularUInt32Field(value: self.moonriseHour, fieldNumber: 1)
    }
    if self.moonriseMin != 0 {
      try visitor.visitSingularUInt32Field(value: self.moonriseMin, fieldNumber: 2)
    }
    if self.moonsetHour != 0 {
      try visitor.visitSingularUInt32Field(value: self.moonsetHour, fieldNumber: 3)
    }
    if self.moonsetMin != 0 {
      try visitor.visitSingularUInt32Field(value: self.moonsetMin, fieldNumber: 4)
    }
    if self.phase != .newMoon {
      try visitor.visitSingularEnumField(value: self.phase, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_weather_moon_item, rhs: protocol_weather_moon_item) -> Bool {
    if lhs.moonriseHour != rhs.moonriseHour {return false}
    if lhs.moonriseMin != rhs.moonriseMin {return false}
    if lhs.moonsetHour != rhs.moonsetHour {return false}
    if lhs.moonsetMin != rhs.moonsetMin {return false}
    if lhs.phase != rhs.phase {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_weather_detail_data_item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_weather_detail_data_item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "month"),
    2: .same(proto: "day"),
    3: .same(proto: "hour"),
    4: .same(proto: "min"),
    5: .same(proto: "week"),
    6: .standard(proto: "weather_type"),
    7: .standard(proto: "cur_temp"),
    8: .standard(proto: "cur_max_temp"),
    9: .standard(proto: "cur_min_temp"),
    10: .standard(proto: "city_name"),
    11: .standard(proto: "hours_weather_items"),
    12: .standard(proto: "air_quality"),
    13: .standard(proto: "rainfall_probability"),
    14: .same(proto: "humidity"),
    15: .standard(proto: "ultraviolet_intensity"),
    16: .standard(proto: "wind_speed"),
    17: .standard(proto: "wind_level"),
    18: .standard(proto: "wind_direction"),
    19: .standard(proto: "future_items"),
    20: .standard(proto: "sunrise_item"),
    21: .same(proto: "location"),
    22: .standard(proto: "atmos_hpa"),
    23: .standard(proto: "uv_items"),
    24: .standard(proto: "moon_item"),
    25: .standard(proto: "sunrise_items"),
    26: .standard(proto: "atmos_hpa_items"),
    27: .same(proto: "visibility"),
    28: .standard(proto: "visibility_level"),
  ]

  fileprivate class _StorageClass {
    var _month: UInt32 = 0
    var _day: UInt32 = 0
    var _hour: UInt32 = 0
    var _min: UInt32 = 0
    var _week: UInt32 = 0
    var _weatherType: weather_type = .tornado
    var _curTemp: Int32 = 0
    var _curMaxTemp: Int32 = 0
    var _curMinTemp: Int32 = 0
    var _cityName: Data = Data()
    var _hoursWeatherItems: [protocol_weather_hour_weather_item] = []
    var _airQuality: UInt32 = 0
    var _rainfallProbability: UInt32 = 0
    var _humidity: UInt32 = 0
    var _ultravioletIntensity: UInt32 = 0
    var _windSpeed: UInt32 = 0
    var _windLevel: UInt32 = 0
    var _windDirection: wind_direction_type = .weatherDirectionN
    var _futureItems: [protocol_weather_future_item] = []
    var _sunriseItem: protocol_weather_sunrise_item? = nil
    var _location: Bool = false
    var _atmosHpa: UInt32 = 0
    var _uvItems: [UInt32] = []
    var _moonItem: [protocol_weather_moon_item] = []
    var _sunriseItems: [protocol_weather_sunrise_item] = []
    var _atmosHpaItems: [UInt32] = []
    var _visibility: UInt32 = 0
    var _visibilityLevel: Data = Data()

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _month = source._month
      _day = source._day
      _hour = source._hour
      _min = source._min
      _week = source._week
      _weatherType = source._weatherType
      _curTemp = source._curTemp
      _curMaxTemp = source._curMaxTemp
      _curMinTemp = source._curMinTemp
      _cityName = source._cityName
      _hoursWeatherItems = source._hoursWeatherItems
      _airQuality = source._airQuality
      _rainfallProbability = source._rainfallProbability
      _humidity = source._humidity
      _ultravioletIntensity = source._ultravioletIntensity
      _windSpeed = source._windSpeed
      _windLevel = source._windLevel
      _windDirection = source._windDirection
      _futureItems = source._futureItems
      _sunriseItem = source._sunriseItem
      _location = source._location
      _atmosHpa = source._atmosHpa
      _uvItems = source._uvItems
      _moonItem = source._moonItem
      _sunriseItems = source._sunriseItems
      _atmosHpaItems = source._atmosHpaItems
      _visibility = source._visibility
      _visibilityLevel = source._visibilityLevel
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._month) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._day) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._hour) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._min) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._week) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._weatherType) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._curTemp) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._curMaxTemp) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._curMinTemp) }()
        case 10: try { try decoder.decodeSingularBytesField(value: &_storage._cityName) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._hoursWeatherItems) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._airQuality) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._rainfallProbability) }()
        case 14: try { try decoder.decodeSingularUInt32Field(value: &_storage._humidity) }()
        case 15: try { try decoder.decodeSingularUInt32Field(value: &_storage._ultravioletIntensity) }()
        case 16: try { try decoder.decodeSingularUInt32Field(value: &_storage._windSpeed) }()
        case 17: try { try decoder.decodeSingularUInt32Field(value: &_storage._windLevel) }()
        case 18: try { try decoder.decodeSingularEnumField(value: &_storage._windDirection) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._futureItems) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._sunriseItem) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._location) }()
        case 22: try { try decoder.decodeSingularUInt32Field(value: &_storage._atmosHpa) }()
        case 23: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._uvItems) }()
        case 24: try { try decoder.decodeRepeatedMessageField(value: &_storage._moonItem) }()
        case 25: try { try decoder.decodeRepeatedMessageField(value: &_storage._sunriseItems) }()
        case 26: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._atmosHpaItems) }()
        case 27: try { try decoder.decodeSingularUInt32Field(value: &_storage._visibility) }()
        case 28: try { try decoder.decodeSingularBytesField(value: &_storage._visibilityLevel) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._month != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._month, fieldNumber: 1)
      }
      if _storage._day != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._day, fieldNumber: 2)
      }
      if _storage._hour != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._hour, fieldNumber: 3)
      }
      if _storage._min != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._min, fieldNumber: 4)
      }
      if _storage._week != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._week, fieldNumber: 5)
      }
      if _storage._weatherType != .tornado {
        try visitor.visitSingularEnumField(value: _storage._weatherType, fieldNumber: 6)
      }
      if _storage._curTemp != 0 {
        try visitor.visitSingularInt32Field(value: _storage._curTemp, fieldNumber: 7)
      }
      if _storage._curMaxTemp != 0 {
        try visitor.visitSingularInt32Field(value: _storage._curMaxTemp, fieldNumber: 8)
      }
      if _storage._curMinTemp != 0 {
        try visitor.visitSingularInt32Field(value: _storage._curMinTemp, fieldNumber: 9)
      }
      if !_storage._cityName.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._cityName, fieldNumber: 10)
      }
      if !_storage._hoursWeatherItems.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._hoursWeatherItems, fieldNumber: 11)
      }
      if _storage._airQuality != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._airQuality, fieldNumber: 12)
      }
      if _storage._rainfallProbability != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._rainfallProbability, fieldNumber: 13)
      }
      if _storage._humidity != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._humidity, fieldNumber: 14)
      }
      if _storage._ultravioletIntensity != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._ultravioletIntensity, fieldNumber: 15)
      }
      if _storage._windSpeed != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._windSpeed, fieldNumber: 16)
      }
      if _storage._windLevel != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._windLevel, fieldNumber: 17)
      }
      if _storage._windDirection != .weatherDirectionN {
        try visitor.visitSingularEnumField(value: _storage._windDirection, fieldNumber: 18)
      }
      if !_storage._futureItems.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._futureItems, fieldNumber: 19)
      }
      try { if let v = _storage._sunriseItem {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      if _storage._location != false {
        try visitor.visitSingularBoolField(value: _storage._location, fieldNumber: 21)
      }
      if _storage._atmosHpa != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._atmosHpa, fieldNumber: 22)
      }
      if !_storage._uvItems.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._uvItems, fieldNumber: 23)
      }
      if !_storage._moonItem.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._moonItem, fieldNumber: 24)
      }
      if !_storage._sunriseItems.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sunriseItems, fieldNumber: 25)
      }
      if !_storage._atmosHpaItems.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._atmosHpaItems, fieldNumber: 26)
      }
      if _storage._visibility != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._visibility, fieldNumber: 27)
      }
      if !_storage._visibilityLevel.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._visibilityLevel, fieldNumber: 28)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_weather_detail_data_item, rhs: protocol_weather_detail_data_item) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._month != rhs_storage._month {return false}
        if _storage._day != rhs_storage._day {return false}
        if _storage._hour != rhs_storage._hour {return false}
        if _storage._min != rhs_storage._min {return false}
        if _storage._week != rhs_storage._week {return false}
        if _storage._weatherType != rhs_storage._weatherType {return false}
        if _storage._curTemp != rhs_storage._curTemp {return false}
        if _storage._curMaxTemp != rhs_storage._curMaxTemp {return false}
        if _storage._curMinTemp != rhs_storage._curMinTemp {return false}
        if _storage._cityName != rhs_storage._cityName {return false}
        if _storage._hoursWeatherItems != rhs_storage._hoursWeatherItems {return false}
        if _storage._airQuality != rhs_storage._airQuality {return false}
        if _storage._rainfallProbability != rhs_storage._rainfallProbability {return false}
        if _storage._humidity != rhs_storage._humidity {return false}
        if _storage._ultravioletIntensity != rhs_storage._ultravioletIntensity {return false}
        if _storage._windSpeed != rhs_storage._windSpeed {return false}
        if _storage._windLevel != rhs_storage._windLevel {return false}
        if _storage._windDirection != rhs_storage._windDirection {return false}
        if _storage._futureItems != rhs_storage._futureItems {return false}
        if _storage._sunriseItem != rhs_storage._sunriseItem {return false}
        if _storage._location != rhs_storage._location {return false}
        if _storage._atmosHpa != rhs_storage._atmosHpa {return false}
        if _storage._uvItems != rhs_storage._uvItems {return false}
        if _storage._moonItem != rhs_storage._moonItem {return false}
        if _storage._sunriseItems != rhs_storage._sunriseItems {return false}
        if _storage._atmosHpaItems != rhs_storage._atmosHpaItems {return false}
        if _storage._visibility != rhs_storage._visibility {return false}
        if _storage._visibilityLevel != rhs_storage._visibilityLevel {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_weather_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_weather_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "switch_flag"),
    3: .standard(proto: "detail_data_item"),
    4: .same(proto: "latitude"),
    5: .same(proto: "longitude"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.switchFlag) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.detailDataItem) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.latitude) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.longitude) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.switchFlag != false {
      try visitor.visitSingularBoolField(value: self.switchFlag, fieldNumber: 2)
    }
    if !self.detailDataItem.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.detailDataItem, fieldNumber: 3)
    }
    if self.latitude != 0 {
      try visitor.visitSingularInt32Field(value: self.latitude, fieldNumber: 4)
    }
    if self.longitude != 0 {
      try visitor.visitSingularInt32Field(value: self.longitude, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_weather_operate, rhs: protocol_weather_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.switchFlag != rhs.switchFlag {return false}
    if lhs.detailDataItem != rhs.detailDataItem {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_weather_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_weather_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "func_table"),
    2: .standard(proto: "weather_support_max"),
    3: .same(proto: "operate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.funcTable) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.weatherSupportMax) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.funcTable != 0 {
      try visitor.visitSingularUInt32Field(value: self.funcTable, fieldNumber: 1)
    }
    if self.weatherSupportMax != 0 {
      try visitor.visitSingularUInt32Field(value: self.weatherSupportMax, fieldNumber: 2)
    }
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_weather_inquire_reply, rhs: protocol_weather_inquire_reply) -> Bool {
    if lhs.funcTable != rhs.funcTable {return false}
    if lhs.weatherSupportMax != rhs.weatherSupportMax {return false}
    if lhs.operate != rhs.operate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
