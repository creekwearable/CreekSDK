// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: enums.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

///package com.example.enums;

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum operate_type: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case invalid // = 0

  ///query
  case inquire // = 1

  ///set
  case set // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalid
    case 1: self = .inquire
    case 2: self = .set
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalid: return 0
    case .inquire: return 1
    case .set: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension operate_type: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [operate_type] = [
    .invalid,
    .inquire,
    .set,
  ]
}

#endif  // swift(>=4.2)

public enum Platform: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case jx3085CPlatform // = 0
  case jx3085LPlatform // = 1
  case jx3085EPlatform // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .jx3085CPlatform
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .jx3085CPlatform
    case 1: self = .jx3085LPlatform
    case 2: self = .jx3085EPlatform
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .jx3085CPlatform: return 0
    case .jx3085LPlatform: return 1
    case .jx3085EPlatform: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Platform: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Platform] = [
    .jx3085CPlatform,
    .jx3085LPlatform,
    .jx3085EPlatform,
  ]
}

#endif  // swift(>=4.2)

public enum Shape: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///square
  case squareShape // = 0

  ///round shape
  case roundShape // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .squareShape
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .squareShape
    case 1: self = .roundShape
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .squareShape: return 0
    case .roundShape: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Shape: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Shape] = [
    .squareShape,
    .roundShape,
  ]
}

#endif  // swift(>=4.2)

public enum Dev_type: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Watch
  case watchType // = 0

  ///bracelet
  case bandType // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .watchType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .watchType
    case 1: self = .bandType
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .watchType: return 0
    case .bandType: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Dev_type: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Dev_type] = [
    .watchType,
    .bandType,
  ]
}

#endif  // swift(>=4.2)

public enum Batt_mode: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// invalid
  case invalidMode // = 0

  ///normal mode (not power saving mode)
  case normalMode // = 1

  ///power saving mode
  case ecoMode // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalidMode
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalidMode
    case 1: self = .normalMode
    case 2: self = .ecoMode
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalidMode: return 0
    case .normalMode: return 1
    case .ecoMode: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Batt_mode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Batt_mode] = [
    .invalidMode,
    .normalMode,
    .ecoMode,
  ]
}

#endif  // swift(>=4.2)

public enum Batt_status: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// not charging
  case normal // = 0

  ///charging
  case charing // = 1

  ///full charge
  case full // = 2

  ///low battery
  case low // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .normal
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .normal
    case 1: self = .charing
    case 2: self = .full
    case 3: self = .low
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .normal: return 0
    case .charing: return 1
    case .full: return 2
    case .low: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Batt_status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Batt_status] = [
    .normal,
    .charing,
    .full,
    .low,
  ]
}

#endif  // swift(>=4.2)

public enum disp_status: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case dispOff // = 0
  case dispOn // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .dispOff
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .dispOff
    case 1: self = .dispOn
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .dispOff: return 0
    case .dispOn: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension disp_status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [disp_status] = [
    .dispOff,
    .dispOn,
  ]
}

#endif  // swift(>=4.2)

public enum alarm_type: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// get up
  case getUp // = 0

  ///sleep
  case sleep // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .getUp
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .getUp
    case 1: self = .sleep
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .getUp: return 0
    case .sleep: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension alarm_type: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [alarm_type] = [
    .getUp,
    .sleep,
  ]
}

#endif  // swift(>=4.2)

public enum bind_method: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///authorization code verification
  case bindEncrypted // = 0

  ///direct binding
  case bindNormal // = 1

  ///Unbind
  case bindRemove // = 2

  ///Pairing code binding
  case bindPairingCode // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .bindEncrypted
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .bindEncrypted
    case 1: self = .bindNormal
    case 2: self = .bindRemove
    case 3: self = .bindPairingCode
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .bindEncrypted: return 0
    case .bindNormal: return 1
    case .bindRemove: return 2
    case .bindPairingCode: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension bind_method: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [bind_method] = [
    .bindEncrypted,
    .bindNormal,
    .bindRemove,
    .bindPairingCode,
  ]
}

#endif  // swift(>=4.2)

public enum bind_flag: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Represents request binding
  case request // = 0

  ///Failed
  case failed // = 1

  ///success
  case success // = 2

  ///Bound
  case bound // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .request
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .request
    case 1: self = .failed
    case 2: self = .success
    case 3: self = .bound
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .request: return 0
    case .failed: return 1
    case .success: return 2
    case .bound: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension bind_flag: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [bind_flag] = [
    .request,
    .failed,
    .success,
    .bound,
  ]
}

#endif  // swift(>=4.2)

public enum bind_phone_type: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Android
  case android // = 0

  ///IOS phone
  case ios // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .android
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .android
    case 1: self = .ios
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .android: return 0
    case .ios: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension bind_phone_type: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [bind_phone_type] = [
    .android,
    .ios,
  ]
}

#endif  // swift(>=4.2)

public enum call_status: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///The incoming call has been answered
  case receivedCall // = 0

  ///The call has been rejected
  case rejectCall // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .receivedCall
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .receivedCall
    case 1: self = .rejectCall
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .receivedCall: return 0
    case .rejectCall: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension call_status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [call_status] = [
    .receivedCall,
    .rejectCall,
  ]
}

#endif  // swift(>=4.2)

public enum quick_card_type: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case cardTypeExercise // = 0
  case cardTypeWeather // = 1
  case cardTypeSuggest // = 2
  case cardTypeDial // = 3
  case cardTypeActivity // = 4
  case cardTypeHeartrate // = 5
  case cardTypeSleep // = 6

  ///Step counting
  case cardTypeSteps // = 7
  case cardTypeSpo2 // = 8

  ///Female menstrual cycle
  case cardTypeMenstruation // = 9

  ///One-click measurement (blood oxygen, heart rate, pressure)
  case cardTypeMeasurement // = 10

  ///Trajectories and activities of the latest outdoor exercise
  case cardTypeRecentWorkout // = 11
  case cardTypeHrv // = 12

  ///Ultraviolet
  case cardTypeUv // = 13

  ///Moonrise, moonset, sunrise and sunset
  case cardTypeAstronomy // = 14

  ///World clock
  case cardTypeWorldClock // = 15

  ///alexa
  case cardTypeAlexa // = 16
  case UNRECOGNIZED(Int)

  public init() {
    self = .cardTypeExercise
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .cardTypeExercise
    case 1: self = .cardTypeWeather
    case 2: self = .cardTypeSuggest
    case 3: self = .cardTypeDial
    case 4: self = .cardTypeActivity
    case 5: self = .cardTypeHeartrate
    case 6: self = .cardTypeSleep
    case 7: self = .cardTypeSteps
    case 8: self = .cardTypeSpo2
    case 9: self = .cardTypeMenstruation
    case 10: self = .cardTypeMeasurement
    case 11: self = .cardTypeRecentWorkout
    case 12: self = .cardTypeHrv
    case 13: self = .cardTypeUv
    case 14: self = .cardTypeAstronomy
    case 15: self = .cardTypeWorldClock
    case 16: self = .cardTypeAlexa
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .cardTypeExercise: return 0
    case .cardTypeWeather: return 1
    case .cardTypeSuggest: return 2
    case .cardTypeDial: return 3
    case .cardTypeActivity: return 4
    case .cardTypeHeartrate: return 5
    case .cardTypeSleep: return 6
    case .cardTypeSteps: return 7
    case .cardTypeSpo2: return 8
    case .cardTypeMenstruation: return 9
    case .cardTypeMeasurement: return 10
    case .cardTypeRecentWorkout: return 11
    case .cardTypeHrv: return 12
    case .cardTypeUv: return 13
    case .cardTypeAstronomy: return 14
    case .cardTypeWorldClock: return 15
    case .cardTypeAlexa: return 16
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension quick_card_type: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [quick_card_type] = [
    .cardTypeExercise,
    .cardTypeWeather,
    .cardTypeSuggest,
    .cardTypeDial,
    .cardTypeActivity,
    .cardTypeHeartrate,
    .cardTypeSleep,
    .cardTypeSteps,
    .cardTypeSpo2,
    .cardTypeMenstruation,
    .cardTypeMeasurement,
    .cardTypeRecentWorkout,
    .cardTypeHrv,
    .cardTypeUv,
    .cardTypeAstronomy,
    .cardTypeWorldClock,
    .cardTypeAlexa,
  ]
}

#endif  // swift(>=4.2)

public enum sync_type: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///heart rate
  case syncHeartRate // = 0

  ///pressure
  case syncStress // = 1

  /// blood oxygen
  case syncSpo2 // = 2

  ///sleep
  case syncSleep // = 3

  ///Motion data
  case syncWorkout // = 4

  ///Daily activity data
  case syncActivity // = 5

  ///swimming data
  case syncSwimming // = 6

  ///gps
  case syncGps // = 7

  ///noise
  case syncNoise // = 8

  ///body power
  case syncBodyEnergy // = 9

  ///Respiratory rate
  case syncRespiratoryRate // = 10

  ///skin temperature
  case syncSkinTemperature // = 11
  case UNRECOGNIZED(Int)

  public init() {
    self = .syncHeartRate
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .syncHeartRate
    case 1: self = .syncStress
    case 2: self = .syncSpo2
    case 3: self = .syncSleep
    case 4: self = .syncWorkout
    case 5: self = .syncActivity
    case 6: self = .syncSwimming
    case 7: self = .syncGps
    case 8: self = .syncNoise
    case 9: self = .syncBodyEnergy
    case 10: self = .syncRespiratoryRate
    case 11: self = .syncSkinTemperature
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .syncHeartRate: return 0
    case .syncStress: return 1
    case .syncSpo2: return 2
    case .syncSleep: return 3
    case .syncWorkout: return 4
    case .syncActivity: return 5
    case .syncSwimming: return 6
    case .syncGps: return 7
    case .syncNoise: return 8
    case .syncBodyEnergy: return 9
    case .syncRespiratoryRate: return 10
    case .syncSkinTemperature: return 11
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension sync_type: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [sync_type] = [
    .syncHeartRate,
    .syncStress,
    .syncSpo2,
    .syncSleep,
    .syncWorkout,
    .syncActivity,
    .syncSwimming,
    .syncGps,
    .syncNoise,
    .syncBodyEnergy,
    .syncRespiratoryRate,
    .syncSkinTemperature,
  ]
}

#endif  // swift(>=4.2)

public enum sync_operate: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case startSync // = 0
  case endSync // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .startSync
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .startSync
    case 1: self = .endSync
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .startSync: return 0
    case .endSync: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension sync_operate: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [sync_operate] = [
    .startSync,
    .endSync,
  ]
}

#endif  // swift(>=4.2)

public enum language: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///invalid
  case langInvalid // = 0

  ///Chinese
  case chinese // = 1

  ///English
  case english // = 2

  ///German
  case german // = 3

  ///Spanish
  case spanish // = 4

  ///Italian
  case italian // = 5

  ///Japanese
  case japanese // = 6

  ///Russian
  case russian // = 7

  ///Portuguese
  case portuguese // = 8

  ///French
  case french // = 9

  ///Korean
  case korean // = 10

  ///Polish
  case polish // = 11
  case UNRECOGNIZED(Int)

  public init() {
    self = .langInvalid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .langInvalid
    case 1: self = .chinese
    case 2: self = .english
    case 3: self = .german
    case 4: self = .spanish
    case 5: self = .italian
    case 6: self = .japanese
    case 7: self = .russian
    case 8: self = .portuguese
    case 9: self = .french
    case 10: self = .korean
    case 11: self = .polish
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .langInvalid: return 0
    case .chinese: return 1
    case .english: return 2
    case .german: return 3
    case .spanish: return 4
    case .italian: return 5
    case .japanese: return 6
    case .russian: return 7
    case .portuguese: return 8
    case .french: return 9
    case .korean: return 10
    case .polish: return 11
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension language: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [language] = [
    .langInvalid,
    .chinese,
    .english,
    .german,
    .spanish,
    .italian,
    .japanese,
    .russian,
    .portuguese,
    .french,
    .korean,
    .polish,
  ]
}

#endif  // swift(>=4.2)

public enum log_operate_type: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case logStart // = 0
  case logEnd // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .logStart
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .logStart
    case 1: self = .logEnd
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .logStart: return 0
    case .logEnd: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension log_operate_type: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [log_operate_type] = [
    .logStart,
    .logEnd,
  ]
}

#endif  // swift(>=4.2)

public enum period_log: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///No record
  case null // = 0

  ///No blood volume
  case notFlow // = 1

  ///As usual
  case asUsual // = 2

  ///Less blood volume
  case lightFlow // = 3

  ///Medium blood volume
  case mendiumFlow // = 4

  ///Large blood volume
  case heavyFlow // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .null
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .null
    case 1: self = .notFlow
    case 2: self = .asUsual
    case 3: self = .lightFlow
    case 4: self = .mendiumFlow
    case 5: self = .heavyFlow
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .null: return 0
    case .notFlow: return 1
    case .asUsual: return 2
    case .lightFlow: return 3
    case .mendiumFlow: return 4
    case .heavyFlow: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension period_log: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [period_log] = [
    .null,
    .notFlow,
    .asUsual,
    .lightFlow,
    .mendiumFlow,
    .heavyFlow,
  ]
}

#endif  // swift(>=4.2)

public enum notify_type: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Allow notifications
  case allow // = 0

  ///Silent notification
  case silent // = 1

  ///close notification
  case close // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .allow
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .allow
    case 1: self = .silent
    case 2: self = .close
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .allow: return 0
    case .silent: return 1
    case .close: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension notify_type: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [notify_type] = [
    .allow,
    .silent,
    .close,
  ]
}

#endif  // swift(>=4.2)

public enum health_monitor_mode: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Manual
  case manual // = 0

  ///automatically
  case auto // = 1

  ///continuous monitoring
  case continuous // = 2

  ///intelligent monitoring
  case intellihent // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .manual
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .manual
    case 1: self = .auto
    case 2: self = .continuous
    case 3: self = .intellihent
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .manual: return 0
    case .auto: return 1
    case .continuous: return 2
    case .intellihent: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension health_monitor_mode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [health_monitor_mode] = [
    .manual,
    .auto,
    .continuous,
    .intellihent,
  ]
}

#endif  // swift(>=4.2)

public enum health_type: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///heart rate
  case heartRate // = 0

  ///pressure
  case stress // = 1

  /// blood oxygen
  case spo2 // = 2

  ///noise
  case noise // = 3

  ///body power
  case bodyEnergy // = 4

  ///Respiratory rate
  case respiratoryRate // = 5

  ///skin temperature
  case skinTemperature // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .heartRate
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .heartRate
    case 1: self = .stress
    case 2: self = .spo2
    case 3: self = .noise
    case 4: self = .bodyEnergy
    case 5: self = .respiratoryRate
    case 6: self = .skinTemperature
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .heartRate: return 0
    case .stress: return 1
    case .spo2: return 2
    case .noise: return 3
    case .bodyEnergy: return 4
    case .respiratoryRate: return 5
    case .skinTemperature: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension health_type: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [health_type] = [
    .heartRate,
    .stress,
    .spo2,
    .noise,
    .bodyEnergy,
    .respiratoryRate,
    .skinTemperature,
  ]
}

#endif  // swift(>=4.2)

public enum music_status: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///invalid
  case invalid // = 0

  ///Play
  case play // = 1

  ///Pause
  case pause // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalid
    case 1: self = .play
    case 2: self = .pause
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalid: return 0
    case .play: return 1
    case .pause: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension music_status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [music_status] = [
    .invalid,
    .play,
    .pause,
  ]
}

#endif  // swift(>=4.2)

public enum operate_II_type: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// increase
  case insert // = 0

  ///delete
  case delete // = 1

  ///Change
  case update // = 2

  ///check
  case read // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .insert
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .insert
    case 1: self = .delete
    case 2: self = .update
    case 3: self = .read
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .insert: return 0
    case .delete: return 1
    case .update: return 2
    case .read: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension operate_II_type: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [operate_II_type] = [
    .insert,
    .delete,
    .update,
    .read,
  ]
}

#endif  // swift(>=4.2)

public enum sensor_operate_type: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case sensorTranStart // = 0
  case sensorTranEnd // = 1
  case offLineTranStart // = 2
  case offLineTranEnd // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .sensorTranStart
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sensorTranStart
    case 1: self = .sensorTranEnd
    case 2: self = .offLineTranStart
    case 3: self = .offLineTranEnd
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .sensorTranStart: return 0
    case .sensorTranEnd: return 1
    case .offLineTranStart: return 2
    case .offLineTranEnd: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension sensor_operate_type: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [sensor_operate_type] = [
    .sensorTranStart,
    .sensorTranEnd,
    .offLineTranStart,
    .offLineTranEnd,
  ]
}

#endif  // swift(>=4.2)

public enum sleep_monitor_type: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///General sleep
  case general // = 0

  ///scientific sleep
  case science // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .general
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .general
    case 1: self = .science
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .general: return 0
    case .science: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension sleep_monitor_type: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [sleep_monitor_type] = [
    .general,
    .science,
  ]
}

#endif  // swift(>=4.2)

public enum sport_type: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Outdoor running
  case orun // = 0

  ///Indoor running
  case irun // = 1

  ///Walking outdoors
  case owalk // = 2

  ///Indoor walking
  case iwalk // = 3

  ///Hiking
  case hiking // = 4

  ///Outdoor cycling
  case ocycle // = 5

  ///Indoor cycling
  case icycle // = 6

  ///cricket
  case cricket // = 7

  ///football
  case football // = 8

  ///Pool swimming
  case pswim // = 9

  ///Open area swimming
  case oswim // = 10

  ///Yoga
  case yoga // = 11

  ///Pilates
  case pilates // = 12

  ///Dance
  case dance // = 13

  ///Zumba dance
  case zumba // = 14

  ///rowing machine
  case rower // = 15

  ///elliptical machine
  case elliptical // = 16

  ///Core training
  case ctraining // = 17

  ///Traditional strength training
  case tstraining // = 18

  ///Functional strength training
  case fstraining // = 19

  ///HIIT
  case hiit // = 20

  ///Tidy up and relax
  case cooldown // = 21

  ///Free training
  case workout // = 22

  ///Fitness
  case fitness // = 23

  ///Trail running
  case trailRunning // = 24

  /// fitness
  case treadmill // = 25

  ///aerobics
  case aerobics // = 26

  ///Sit-ups
  case sitUp // = 27

  ///Plank support
  case plank // = 28

  ///Jumping and jacking
  case jumpingJack // = 29

  ///Pull-ups
  case chinUp // = 30

  ///Push-ups
  case pushUp // = 31

  ///Squat
  case deepSquat // = 32

  ///raise legs high
  case highKneeLift // = 33

  ///dumbbell
  case dumbbell // = 34

  ///barbell
  case barbell // = 35

  ///boxing
  case boxing // = 36

  ///free fighting
  case kickboxing // = 37

  ///horizontal bar
  case horizontalBar // = 38

  ///parallel bars
  case parallelBars // = 39

  ///Walking machine
  case walkingMachine // = 40

  ///climbing machine
  case summitTrainers // = 41

  ///Balls
  case bowling // = 42

  ///tennis
  case tennis // = 43

  ///Table tennis
  case tableTennis // = 44

  ///golf ball
  case golf // = 45

  ///Basketball
  case basketball // = 46

  ///Badminton
  case badminton // = 47

  ///Hockey
  case hockey // = 48

  ///rugby
  case rugby // = 49

  ///Handball
  case handball // = 50

  ///Squash
  case squash // = 51

  ///baseball
  case baseball // = 52

  ///softball
  case softball // = 53

  ///Shuttlecock
  case shuttlecock // = 54

  /// Sepak Takraw
  case sepaktakraw // = 55

  ///Leisure sport
  case streetDance // = 56

  ///Mounting
  case mountainClinbing // = 57

  ///skipping rope
  case ropeSkipping // = 58

  ///Climb stairs
  case climbStairs // = 59

  ///Ballet
  case ballet // = 60

  ///Social dance
  case socialDance // = 61

  ///darts
  case darts // = 62

  ///Horse riding
  case horsebackRiding // = 63

  ///Roller skating
  case rollerSkating // = 64

  ///Tai Chi
  case taiChi // = 65

  ///Frisbee
  case frisbee // = 66

  ///Hula hoop
  case hulaHoop // = 67

  ///ice and snow sports
  case sleigh // = 68

  ///skating
  case skating // = 69

  ///Snowmobile
  case bobsleighAndTobogganing // = 70

  ///curling
  case curling // = 71

  ///ice hockey
  case iceHockey // = 72

  ///water sports
  case surfing // = 73

  ///Sailboat
  case sailboat // = 74

  ///Sailboard
  case sailboard // = 75

  ///Kayak
  case foldboating // = 76

  ///rowing boat
  case canoeing // = 77

  /// rowing
  case boatRace // = 78

  ///Motorboat
  case motorboat // = 79

  ///water polo
  case waterPolo // = 80

  ///Extreme sport
  case slidingPlate // = 81

  ///rock climbing
  case rockClimbing // = 82

  ///Bungee jumping
  case bungeeJumping // = 83

  ///Parkour
  case parkour // = 84

  ///Other
  case other // = 85

  ///Add new sports
  case spinning // = 86

  ///Martial Arts
  case martialArts // = 87

  ///Taekwondo
  case taekwondo // = 88

  ///Karate
  case karate // = 89

  ///gymnastics
  case gymnastics // = 90

  ///cage tennis
  case padel // = 91

  ///pickleball
  case pickleball // = 92

  ///Snowboarding
  case snowboarding // = 93

  ///Skiing
  case skiing // = 94

  ///Paddle
  case paddling // = 95

  ///BMX
  case bmx // = 96

  ///Fencing
  case fencing // = 97

  ///Billiards
  case billiards // = 98

  ///Beach Soccer
  case beachSoccer // = 99

  ///Beach volleyball
  case beachVolleyball // = 100

  ///Dodgeball
  case dodgeball // = 101

  ///Jazz dance
  case jazz // = 102

  ///Latin dance
  case latin // = 103

  ///Square dance
  case squareDance // = 104

  ///Volleyball
  case volleyball // = 105

  ///Kite flying
  case kiteFlying // = 106

  ///Fishing
  case fishing // = 107

  ///Archery
  case archery // = 108

  ///shooting
  case shooting // = 109

  ///Rafting
  case whiteWaterRafting // = 110

  ///Alpine skiing
  case alpineSkiing // = 111

  ///cross-country skiing
  case crossCountrySkiing // = 112

  ///biathlon
  case biathon // = 113

  ///Dragon boat
  case dragonBoatRacing // = 114

  ///racing
  case racing // = 115
  case UNRECOGNIZED(Int)

  public init() {
    self = .orun
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .orun
    case 1: self = .irun
    case 2: self = .owalk
    case 3: self = .iwalk
    case 4: self = .hiking
    case 5: self = .ocycle
    case 6: self = .icycle
    case 7: self = .cricket
    case 8: self = .football
    case 9: self = .pswim
    case 10: self = .oswim
    case 11: self = .yoga
    case 12: self = .pilates
    case 13: self = .dance
    case 14: self = .zumba
    case 15: self = .rower
    case 16: self = .elliptical
    case 17: self = .ctraining
    case 18: self = .tstraining
    case 19: self = .fstraining
    case 20: self = .hiit
    case 21: self = .cooldown
    case 22: self = .workout
    case 23: self = .fitness
    case 24: self = .trailRunning
    case 25: self = .treadmill
    case 26: self = .aerobics
    case 27: self = .sitUp
    case 28: self = .plank
    case 29: self = .jumpingJack
    case 30: self = .chinUp
    case 31: self = .pushUp
    case 32: self = .deepSquat
    case 33: self = .highKneeLift
    case 34: self = .dumbbell
    case 35: self = .barbell
    case 36: self = .boxing
    case 37: self = .kickboxing
    case 38: self = .horizontalBar
    case 39: self = .parallelBars
    case 40: self = .walkingMachine
    case 41: self = .summitTrainers
    case 42: self = .bowling
    case 43: self = .tennis
    case 44: self = .tableTennis
    case 45: self = .golf
    case 46: self = .basketball
    case 47: self = .badminton
    case 48: self = .hockey
    case 49: self = .rugby
    case 50: self = .handball
    case 51: self = .squash
    case 52: self = .baseball
    case 53: self = .softball
    case 54: self = .shuttlecock
    case 55: self = .sepaktakraw
    case 56: self = .streetDance
    case 57: self = .mountainClinbing
    case 58: self = .ropeSkipping
    case 59: self = .climbStairs
    case 60: self = .ballet
    case 61: self = .socialDance
    case 62: self = .darts
    case 63: self = .horsebackRiding
    case 64: self = .rollerSkating
    case 65: self = .taiChi
    case 66: self = .frisbee
    case 67: self = .hulaHoop
    case 68: self = .sleigh
    case 69: self = .skating
    case 70: self = .bobsleighAndTobogganing
    case 71: self = .curling
    case 72: self = .iceHockey
    case 73: self = .surfing
    case 74: self = .sailboat
    case 75: self = .sailboard
    case 76: self = .foldboating
    case 77: self = .canoeing
    case 78: self = .boatRace
    case 79: self = .motorboat
    case 80: self = .waterPolo
    case 81: self = .slidingPlate
    case 82: self = .rockClimbing
    case 83: self = .bungeeJumping
    case 84: self = .parkour
    case 85: self = .other
    case 86: self = .spinning
    case 87: self = .martialArts
    case 88: self = .taekwondo
    case 89: self = .karate
    case 90: self = .gymnastics
    case 91: self = .padel
    case 92: self = .pickleball
    case 93: self = .snowboarding
    case 94: self = .skiing
    case 95: self = .paddling
    case 96: self = .bmx
    case 97: self = .fencing
    case 98: self = .billiards
    case 99: self = .beachSoccer
    case 100: self = .beachVolleyball
    case 101: self = .dodgeball
    case 102: self = .jazz
    case 103: self = .latin
    case 104: self = .squareDance
    case 105: self = .volleyball
    case 106: self = .kiteFlying
    case 107: self = .fishing
    case 108: self = .archery
    case 109: self = .shooting
    case 110: self = .whiteWaterRafting
    case 111: self = .alpineSkiing
    case 112: self = .crossCountrySkiing
    case 113: self = .biathon
    case 114: self = .dragonBoatRacing
    case 115: self = .racing
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .orun: return 0
    case .irun: return 1
    case .owalk: return 2
    case .iwalk: return 3
    case .hiking: return 4
    case .ocycle: return 5
    case .icycle: return 6
    case .cricket: return 7
    case .football: return 8
    case .pswim: return 9
    case .oswim: return 10
    case .yoga: return 11
    case .pilates: return 12
    case .dance: return 13
    case .zumba: return 14
    case .rower: return 15
    case .elliptical: return 16
    case .ctraining: return 17
    case .tstraining: return 18
    case .fstraining: return 19
    case .hiit: return 20
    case .cooldown: return 21
    case .workout: return 22
    case .fitness: return 23
    case .trailRunning: return 24
    case .treadmill: return 25
    case .aerobics: return 26
    case .sitUp: return 27
    case .plank: return 28
    case .jumpingJack: return 29
    case .chinUp: return 30
    case .pushUp: return 31
    case .deepSquat: return 32
    case .highKneeLift: return 33
    case .dumbbell: return 34
    case .barbell: return 35
    case .boxing: return 36
    case .kickboxing: return 37
    case .horizontalBar: return 38
    case .parallelBars: return 39
    case .walkingMachine: return 40
    case .summitTrainers: return 41
    case .bowling: return 42
    case .tennis: return 43
    case .tableTennis: return 44
    case .golf: return 45
    case .basketball: return 46
    case .badminton: return 47
    case .hockey: return 48
    case .rugby: return 49
    case .handball: return 50
    case .squash: return 51
    case .baseball: return 52
    case .softball: return 53
    case .shuttlecock: return 54
    case .sepaktakraw: return 55
    case .streetDance: return 56
    case .mountainClinbing: return 57
    case .ropeSkipping: return 58
    case .climbStairs: return 59
    case .ballet: return 60
    case .socialDance: return 61
    case .darts: return 62
    case .horsebackRiding: return 63
    case .rollerSkating: return 64
    case .taiChi: return 65
    case .frisbee: return 66
    case .hulaHoop: return 67
    case .sleigh: return 68
    case .skating: return 69
    case .bobsleighAndTobogganing: return 70
    case .curling: return 71
    case .iceHockey: return 72
    case .surfing: return 73
    case .sailboat: return 74
    case .sailboard: return 75
    case .foldboating: return 76
    case .canoeing: return 77
    case .boatRace: return 78
    case .motorboat: return 79
    case .waterPolo: return 80
    case .slidingPlate: return 81
    case .rockClimbing: return 82
    case .bungeeJumping: return 83
    case .parkour: return 84
    case .other: return 85
    case .spinning: return 86
    case .martialArts: return 87
    case .taekwondo: return 88
    case .karate: return 89
    case .gymnastics: return 90
    case .padel: return 91
    case .pickleball: return 92
    case .snowboarding: return 93
    case .skiing: return 94
    case .paddling: return 95
    case .bmx: return 96
    case .fencing: return 97
    case .billiards: return 98
    case .beachSoccer: return 99
    case .beachVolleyball: return 100
    case .dodgeball: return 101
    case .jazz: return 102
    case .latin: return 103
    case .squareDance: return 104
    case .volleyball: return 105
    case .kiteFlying: return 106
    case .fishing: return 107
    case .archery: return 108
    case .shooting: return 109
    case .whiteWaterRafting: return 110
    case .alpineSkiing: return 111
    case .crossCountrySkiing: return 112
    case .biathon: return 113
    case .dragonBoatRacing: return 114
    case .racing: return 115
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension sport_type: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [sport_type] = [
    .orun,
    .irun,
    .owalk,
    .iwalk,
    .hiking,
    .ocycle,
    .icycle,
    .cricket,
    .football,
    .pswim,
    .oswim,
    .yoga,
    .pilates,
    .dance,
    .zumba,
    .rower,
    .elliptical,
    .ctraining,
    .tstraining,
    .fstraining,
    .hiit,
    .cooldown,
    .workout,
    .fitness,
    .trailRunning,
    .treadmill,
    .aerobics,
    .sitUp,
    .plank,
    .jumpingJack,
    .chinUp,
    .pushUp,
    .deepSquat,
    .highKneeLift,
    .dumbbell,
    .barbell,
    .boxing,
    .kickboxing,
    .horizontalBar,
    .parallelBars,
    .walkingMachine,
    .summitTrainers,
    .bowling,
    .tennis,
    .tableTennis,
    .golf,
    .basketball,
    .badminton,
    .hockey,
    .rugby,
    .handball,
    .squash,
    .baseball,
    .softball,
    .shuttlecock,
    .sepaktakraw,
    .streetDance,
    .mountainClinbing,
    .ropeSkipping,
    .climbStairs,
    .ballet,
    .socialDance,
    .darts,
    .horsebackRiding,
    .rollerSkating,
    .taiChi,
    .frisbee,
    .hulaHoop,
    .sleigh,
    .skating,
    .bobsleighAndTobogganing,
    .curling,
    .iceHockey,
    .surfing,
    .sailboat,
    .sailboard,
    .foldboating,
    .canoeing,
    .boatRace,
    .motorboat,
    .waterPolo,
    .slidingPlate,
    .rockClimbing,
    .bungeeJumping,
    .parkour,
    .other,
    .spinning,
    .martialArts,
    .taekwondo,
    .karate,
    .gymnastics,
    .padel,
    .pickleball,
    .snowboarding,
    .skiing,
    .paddling,
    .bmx,
    .fencing,
    .billiards,
    .beachSoccer,
    .beachVolleyball,
    .dodgeball,
    .jazz,
    .latin,
    .squareDance,
    .volleyball,
    .kiteFlying,
    .fishing,
    .archery,
    .shooting,
    .whiteWaterRafting,
    .alpineSkiing,
    .crossCountrySkiing,
    .biathon,
    .dragonBoatRacing,
    .racing,
  ]
}

#endif  // swift(>=4.2)

public enum interval_division_mode: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Maximum heart rate zone mode
  case maximumMode // = 0

  ///Reserve heart rate interval mode
  case reserveMode // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .maximumMode
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .maximumMode
    case 1: self = .reserveMode
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .maximumMode: return 0
    case .reserveMode: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension interval_division_mode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [interval_division_mode] = [
    .maximumMode,
    .reserveMode,
  ]
}

#endif  // swift(>=4.2)

public enum gender_type: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///male
  case genderMale // = 0

  ///female
  case genderFemale // = 1

  ///other
  case genderOther // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .genderMale
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .genderMale
    case 1: self = .genderFemale
    case 2: self = .genderOther
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .genderMale: return 0
    case .genderFemale: return 1
    case .genderOther: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension gender_type: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [gender_type] = [
    .genderMale,
    .genderFemale,
    .genderOther,
  ]
}

#endif  // swift(>=4.2)

public enum dial_type: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// invalid
  case null // = 0

  ///General cloud dial
  case general // = 1

  ///photo dial
  case photo // = 2

  ///Wallpaper dial
  case wallpaper // = 3

  ///custom dial
  case custom // = 4

  ///Normal dial + screen dial
  case generalAod // = 5

  ///Normal off-screen dial
  case aod // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .null
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .null
    case 1: self = .general
    case 2: self = .photo
    case 3: self = .wallpaper
    case 4: self = .custom
    case 5: self = .generalAod
    case 6: self = .aod
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .null: return 0
    case .general: return 1
    case .photo: return 2
    case .wallpaper: return 3
    case .custom: return 4
    case .generalAod: return 5
    case .aod: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension dial_type: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [dial_type] = [
    .null,
    .general,
    .photo,
    .wallpaper,
    .custom,
    .generalAod,
    .aod,
  ]
}

#endif  // swift(>=4.2)

public enum dial_operate_type: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///The query is using the dial
  case inquire // = 0

  ///Set the dial
  case set // = 1

  ///Delete the dial
  case delete // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .inquire
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .inquire
    case 1: self = .set
    case 2: self = .delete
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .inquire: return 0
    case .set: return 1
    case .delete: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension dial_operate_type: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [dial_operate_type] = [
    .inquire,
    .set,
    .delete,
  ]
}

#endif  // swift(>=4.2)

public enum weather_type: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///tornado
  case tornado // = 0

  ///tropical storm
  case tropicalStorm // = 1

  ///hurricane
  case hurricane // = 2

  ///Strong storms
  case strongStorms // = 3

  ///thunderstorms/thunderstorms
  case thunderstorms // = 4

  ///rain and snow
  case rainSnow // = 5

  ///rain plus hail
  case rainSleet // = 6

  ///mixed rainfall
  case wintryMix // = 7

  ///freezing rain
  case freezingDrizzle // = 8

  /// drizzle
  case drizzle // = 9

  ///freezing rain
  case freezingRain // = 10

  ///showers
  case showers // = 11

  ///Rain
  case rain // = 12

  ///little snow
  case flurries // = 13

  ///Snow showers
  case snowShowers // = 14

  ///drifting snow (wind effect)
  case driftingSnow // = 15

  ///snow
  case snow // = 16

  ///hail
  case hail // = 17

  /// hail/freezing rain
  case sleet // = 18

  ///blowing dust/sandstorm
  case blowingDustSandstorm // = 19

  ///fog
  case foggy // = 20

  ///haze
  case haze // = 21

  ///smoke
  case smoke // = 22

  /// Breeze
  case breezy // = 23

  /// strong wind
  case windy // = 24

  ///cold current
  case iceCrystals // = 25

  /// cloudy
  case cloudy // = 26

  /// cloudy and sunny (evening)
  case mostlyCloudyNight // = 27

  /// cloudy and sunny (daytime)
  case mostlyCloudyDay // = 28

  ///cloudy to sunny (evening)
  case partlyCloudyNight // = 29

  ///cloudy to sunny (daytime)
  case partlyCloudyDay // = 30

  ///Sunny day (evening)
  case clear // = 31

  ///Sunny day (day)
  case sunny // = 32

  ///clear and cloudy (evening)
  case mostlyClear // = 33

  /// sunny and cloudy (daytime)
  case mostlySunny // = 34

  ///rain plus hail
  case mixedRainHail // = 35

  ///Hot
  case hot // = 36

  ///Partial thunderstorms
  case isolatedThunderstorms // = 37

  ///Partial thunderstorms (DAY)
  case scatteredThunderstormsD // = 38

  ///Scattered showers (Night)
  case scatteredShowersNight // = 39

  ///heavy rain
  case heavyRain // = 40

  ///Scattered snow showers
  case scatteredSnowShowersD // = 41

  ///Blizzard
  case heavySnow // = 42

  ///Blizzard
  case blizzard // = 43

  ///no data (unavailable)
  case notAvailable // = 44

  ///Scattered showers (Night)
  case scatteredSnowShowersN // = 45

  ///scattered snow showers
  case scatteredShowers // = 46

  ///Partial thunderstorms (Night)
  case scatteredThunderstormsN // = 47
  case UNRECOGNIZED(Int)

  public init() {
    self = .tornado
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tornado
    case 1: self = .tropicalStorm
    case 2: self = .hurricane
    case 3: self = .strongStorms
    case 4: self = .thunderstorms
    case 5: self = .rainSnow
    case 6: self = .rainSleet
    case 7: self = .wintryMix
    case 8: self = .freezingDrizzle
    case 9: self = .drizzle
    case 10: self = .freezingRain
    case 11: self = .showers
    case 12: self = .rain
    case 13: self = .flurries
    case 14: self = .snowShowers
    case 15: self = .driftingSnow
    case 16: self = .snow
    case 17: self = .hail
    case 18: self = .sleet
    case 19: self = .blowingDustSandstorm
    case 20: self = .foggy
    case 21: self = .haze
    case 22: self = .smoke
    case 23: self = .breezy
    case 24: self = .windy
    case 25: self = .iceCrystals
    case 26: self = .cloudy
    case 27: self = .mostlyCloudyNight
    case 28: self = .mostlyCloudyDay
    case 29: self = .partlyCloudyNight
    case 30: self = .partlyCloudyDay
    case 31: self = .clear
    case 32: self = .sunny
    case 33: self = .mostlyClear
    case 34: self = .mostlySunny
    case 35: self = .mixedRainHail
    case 36: self = .hot
    case 37: self = .isolatedThunderstorms
    case 38: self = .scatteredThunderstormsD
    case 39: self = .scatteredShowersNight
    case 40: self = .heavyRain
    case 41: self = .scatteredSnowShowersD
    case 42: self = .heavySnow
    case 43: self = .blizzard
    case 44: self = .notAvailable
    case 45: self = .scatteredSnowShowersN
    case 46: self = .scatteredShowers
    case 47: self = .scatteredThunderstormsN
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .tornado: return 0
    case .tropicalStorm: return 1
    case .hurricane: return 2
    case .strongStorms: return 3
    case .thunderstorms: return 4
    case .rainSnow: return 5
    case .rainSleet: return 6
    case .wintryMix: return 7
    case .freezingDrizzle: return 8
    case .drizzle: return 9
    case .freezingRain: return 10
    case .showers: return 11
    case .rain: return 12
    case .flurries: return 13
    case .snowShowers: return 14
    case .driftingSnow: return 15
    case .snow: return 16
    case .hail: return 17
    case .sleet: return 18
    case .blowingDustSandstorm: return 19
    case .foggy: return 20
    case .haze: return 21
    case .smoke: return 22
    case .breezy: return 23
    case .windy: return 24
    case .iceCrystals: return 25
    case .cloudy: return 26
    case .mostlyCloudyNight: return 27
    case .mostlyCloudyDay: return 28
    case .partlyCloudyNight: return 29
    case .partlyCloudyDay: return 30
    case .clear: return 31
    case .sunny: return 32
    case .mostlyClear: return 33
    case .mostlySunny: return 34
    case .mixedRainHail: return 35
    case .hot: return 36
    case .isolatedThunderstorms: return 37
    case .scatteredThunderstormsD: return 38
    case .scatteredShowersNight: return 39
    case .heavyRain: return 40
    case .scatteredSnowShowersD: return 41
    case .heavySnow: return 42
    case .blizzard: return 43
    case .notAvailable: return 44
    case .scatteredSnowShowersN: return 45
    case .scatteredShowers: return 46
    case .scatteredThunderstormsN: return 47
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension weather_type: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [weather_type] = [
    .tornado,
    .tropicalStorm,
    .hurricane,
    .strongStorms,
    .thunderstorms,
    .rainSnow,
    .rainSleet,
    .wintryMix,
    .freezingDrizzle,
    .drizzle,
    .freezingRain,
    .showers,
    .rain,
    .flurries,
    .snowShowers,
    .driftingSnow,
    .snow,
    .hail,
    .sleet,
    .blowingDustSandstorm,
    .foggy,
    .haze,
    .smoke,
    .breezy,
    .windy,
    .iceCrystals,
    .cloudy,
    .mostlyCloudyNight,
    .mostlyCloudyDay,
    .partlyCloudyNight,
    .partlyCloudyDay,
    .clear,
    .sunny,
    .mostlyClear,
    .mostlySunny,
    .mixedRainHail,
    .hot,
    .isolatedThunderstorms,
    .scatteredThunderstormsD,
    .scatteredShowersNight,
    .heavyRain,
    .scatteredSnowShowersD,
    .heavySnow,
    .blizzard,
    .notAvailable,
    .scatteredSnowShowersN,
    .scatteredShowers,
    .scatteredThunderstormsN,
  ]
}

#endif  // swift(>=4.2)

///wind direction
public enum wind_direction_type: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///true north
  case weatherDirectionN // = 0

  ///North northeast
  case weatherDirectionNne // = 1

  ///Northeast
  case weatherDirectionNe // = 2

  ///East northeast
  case weatherDirectionEne // = 3

  ///East
  case weatherDirectionE // = 4

  ///East, southeast
  case weatherDirectionEse // = 5

  /// southeast
  case weatherDirectionSe // = 6

  ///south southeast
  case weatherDirectionSse // = 7

  /// south
  case weatherDirectionS // = 8

  ///South Southwest
  case weatherDirectionSsw // = 9

  /// Southwest
  case weatherDirectionSw // = 10

  ///West Southwest
  case weatherDirectionWsw // = 11

  /// West
  case weatherDirectionW // = 12

  ///West Northwest
  case weatherDirectionWnwm // = 13

  ///Northwest
  case weatherDirectionNw // = 14

  ///North and Northwest
  case weatherDirectionNnw // = 15
  case UNRECOGNIZED(Int)

  public init() {
    self = .weatherDirectionN
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .weatherDirectionN
    case 1: self = .weatherDirectionNne
    case 2: self = .weatherDirectionNe
    case 3: self = .weatherDirectionEne
    case 4: self = .weatherDirectionE
    case 5: self = .weatherDirectionEse
    case 6: self = .weatherDirectionSe
    case 7: self = .weatherDirectionSse
    case 8: self = .weatherDirectionS
    case 9: self = .weatherDirectionSsw
    case 10: self = .weatherDirectionSw
    case 11: self = .weatherDirectionWsw
    case 12: self = .weatherDirectionW
    case 13: self = .weatherDirectionWnwm
    case 14: self = .weatherDirectionNw
    case 15: self = .weatherDirectionNnw
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .weatherDirectionN: return 0
    case .weatherDirectionNne: return 1
    case .weatherDirectionNe: return 2
    case .weatherDirectionEne: return 3
    case .weatherDirectionE: return 4
    case .weatherDirectionEse: return 5
    case .weatherDirectionSe: return 6
    case .weatherDirectionSse: return 7
    case .weatherDirectionS: return 8
    case .weatherDirectionSsw: return 9
    case .weatherDirectionSw: return 10
    case .weatherDirectionWsw: return 11
    case .weatherDirectionW: return 12
    case .weatherDirectionWnwm: return 13
    case .weatherDirectionNw: return 14
    case .weatherDirectionNnw: return 15
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension wind_direction_type: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [wind_direction_type] = [
    .weatherDirectionN,
    .weatherDirectionNne,
    .weatherDirectionNe,
    .weatherDirectionEne,
    .weatherDirectionE,
    .weatherDirectionEse,
    .weatherDirectionSe,
    .weatherDirectionSse,
    .weatherDirectionS,
    .weatherDirectionSsw,
    .weatherDirectionSw,
    .weatherDirectionWsw,
    .weatherDirectionW,
    .weatherDirectionWnwm,
    .weatherDirectionNw,
    .weatherDirectionNnw,
  ]
}

#endif  // swift(>=4.2)

public enum moon_phase: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///New moon
  case newMoon // = 0

  ///Emei Yue
  case waxingCrescent // = 1

  ///First quarter moon
  case firstQuarter // = 2

  ///Waxing gibbous moon
  case waxingGibbous // = 3

  ///Full moon
  case fullMoon // = 4

  ///Wanthing gibbous moon
  case waningGibbous // = 5

  ///Last quarter moon
  case lastQuarter // = 6

  ///waning moon
  case waningMoon // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .newMoon
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .newMoon
    case 1: self = .waxingCrescent
    case 2: self = .firstQuarter
    case 3: self = .waxingGibbous
    case 4: self = .fullMoon
    case 5: self = .waningGibbous
    case 6: self = .lastQuarter
    case 7: self = .waningMoon
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .newMoon: return 0
    case .waxingCrescent: return 1
    case .firstQuarter: return 2
    case .waxingGibbous: return 3
    case .fullMoon: return 4
    case .waningGibbous: return 5
    case .lastQuarter: return 6
    case .waningMoon: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension moon_phase: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [moon_phase] = [
    .newMoon,
    .waxingCrescent,
    .firstQuarter,
    .waxingGibbous,
    .fullMoon,
    .waningGibbous,
    .lastQuarter,
    .waningMoon,
  ]
}

#endif  // swift(>=4.2)

public enum message_remind_type: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case null // = 0
  case sms // = 1
  case email // = 2
  case calendar // = 3
  case missedCall // = 4
  case facebook // = 5
  case twitter // = 6
  case instagram // = 7
  case snapchat // = 8
  case whatsapp // = 9
  case line // = 10
  case tiktok // = 11
  case skype // = 12
  case wechat // = 13
  case fitbeing // = 14
  case microsoftTeams // = 15
  case telegramMessenger // = 16
  case messenger // = 17
  case linkedIn // = 18
  case gmail // = 19
  case microsoftOutlook // = 20
  case googleChat // = 21
  case qq // = 22
  case whatsAppBusiness // = 23
  case youtube // = 24
  case uber // = 25
  case uberEats // = 26
  case doorDashMissing // = 27
  case bancoGeneral // = 28
  case bacBank // = 29
  case googleMaps // = 30
  case amazonShopping // = 31
  case spotify // = 32
  case discord // = 33
  case ohter // = 34
  case UNRECOGNIZED(Int)

  public init() {
    self = .null
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .null
    case 1: self = .sms
    case 2: self = .email
    case 3: self = .calendar
    case 4: self = .missedCall
    case 5: self = .facebook
    case 6: self = .twitter
    case 7: self = .instagram
    case 8: self = .snapchat
    case 9: self = .whatsapp
    case 10: self = .line
    case 11: self = .tiktok
    case 12: self = .skype
    case 13: self = .wechat
    case 14: self = .fitbeing
    case 15: self = .microsoftTeams
    case 16: self = .telegramMessenger
    case 17: self = .messenger
    case 18: self = .linkedIn
    case 19: self = .gmail
    case 20: self = .microsoftOutlook
    case 21: self = .googleChat
    case 22: self = .qq
    case 23: self = .whatsAppBusiness
    case 24: self = .youtube
    case 25: self = .uber
    case 26: self = .uberEats
    case 27: self = .doorDashMissing
    case 28: self = .bancoGeneral
    case 29: self = .bacBank
    case 30: self = .googleMaps
    case 31: self = .amazonShopping
    case 32: self = .spotify
    case 33: self = .discord
    case 34: self = .ohter
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .null: return 0
    case .sms: return 1
    case .email: return 2
    case .calendar: return 3
    case .missedCall: return 4
    case .facebook: return 5
    case .twitter: return 6
    case .instagram: return 7
    case .snapchat: return 8
    case .whatsapp: return 9
    case .line: return 10
    case .tiktok: return 11
    case .skype: return 12
    case .wechat: return 13
    case .fitbeing: return 14
    case .microsoftTeams: return 15
    case .telegramMessenger: return 16
    case .messenger: return 17
    case .linkedIn: return 18
    case .gmail: return 19
    case .microsoftOutlook: return 20
    case .googleChat: return 21
    case .qq: return 22
    case .whatsAppBusiness: return 23
    case .youtube: return 24
    case .uber: return 25
    case .uberEats: return 26
    case .doorDashMissing: return 27
    case .bancoGeneral: return 28
    case .bacBank: return 29
    case .googleMaps: return 30
    case .amazonShopping: return 31
    case .spotify: return 32
    case .discord: return 33
    case .ohter: return 34
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension message_remind_type: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [message_remind_type] = [
    .null,
    .sms,
    .email,
    .calendar,
    .missedCall,
    .facebook,
    .twitter,
    .instagram,
    .snapchat,
    .whatsapp,
    .line,
    .tiktok,
    .skype,
    .wechat,
    .fitbeing,
    .microsoftTeams,
    .telegramMessenger,
    .messenger,
    .linkedIn,
    .gmail,
    .microsoftOutlook,
    .googleChat,
    .qq,
    .whatsAppBusiness,
    .youtube,
    .uber,
    .uberEats,
    .doorDashMissing,
    .bancoGeneral,
    .bacBank,
    .googleMaps,
    .amazonShopping,
    .spotify,
    .discord,
    .ohter,
  ]
}

#endif  // swift(>=4.2)

public enum notify_os_platform: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Android
  case androidNotify // = 0
  case iosNotify // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .androidNotify
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .androidNotify
    case 1: self = .iosNotify
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .androidNotify: return 0
    case .iosNotify: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension notify_os_platform: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [notify_os_platform] = [
    .androidNotify,
    .iosNotify,
  ]
}

#endif  // swift(>=4.2)

public enum aod_mode: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case intelligentMode // = 0
  case timerMdoe // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .intelligentMode
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .intelligentMode
    case 1: self = .timerMdoe
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .intelligentMode: return 0
    case .timerMdoe: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension aod_mode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [aod_mode] = [
    .intelligentMode,
    .timerMdoe,
  ]
}

#endif  // swift(>=4.2)

public enum event_id: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case null // = 0

  /// Music control
  case musicControl // = 1

  /// Find phone
  case findPhone // = 2

  /// Notify data update
  case syncData // = 3

  /// Find watch
  case findWatch // = 4

  ///Volume change (required by Alexa)
  case volumeChange // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .null
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .null
    case 1: self = .musicControl
    case 2: self = .findPhone
    case 3: self = .syncData
    case 4: self = .findWatch
    case 5: self = .volumeChange
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .null: return 0
    case .musicControl: return 1
    case .findPhone: return 2
    case .syncData: return 3
    case .findWatch: return 4
    case .volumeChange: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension event_id: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [event_id] = [
    .null,
    .musicControl,
    .findPhone,
    .syncData,
    .findWatch,
    .volumeChange,
  ]
}

#endif  // swift(>=4.2)

public enum long_2s_press_type: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case pressTypeNull // = 0
  case pressTypeSos // = 1
  case pressTypeWorkout // = 2
  case pressTypeAlexa // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .pressTypeNull
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .pressTypeNull
    case 1: self = .pressTypeSos
    case 2: self = .pressTypeWorkout
    case 3: self = .pressTypeAlexa
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .pressTypeNull: return 0
    case .pressTypeSos: return 1
    case .pressTypeWorkout: return 2
    case .pressTypeAlexa: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension long_2s_press_type: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [long_2s_press_type] = [
    .pressTypeNull,
    .pressTypeSos,
    .pressTypeWorkout,
    .pressTypeAlexa,
  ]
}

#endif  // swift(>=4.2)

public enum app_list: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  ///Activity
  case activity // = 0

  ///Sports
  case workout // = 1

  ///Step counting
  case steps // = 2

  ///Heart rate
  case heartrate // = 3

  ///Sleep
  case sleep // = 4

  ///Pressure
  case stress // = 5

  ///Womens Health
  case menstruation // = 6

  ///breathing training
  case breathe // = 7

  ///Alarm clock
  case alarms // = 8

  ///Phone
  case phone // = 9

  ///Countdown
  case timers // = 10

  ///Stopwatch
  case stopwatch // = 11

  ///blood oxygen
  case spo2 // = 12

  ///Weather
  case weather // = 13

  ///Camera control
  case cameraRemote // = 14

  ///Music control
  case music // = 15

  ///Find mobile phone
  case findPhone // = 16

  ///World clock
  case worldClock // = 17

  ///Settings
  case settings // = 18
  case UNRECOGNIZED(Int)

  public init() {
    self = .activity
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .activity
    case 1: self = .workout
    case 2: self = .steps
    case 3: self = .heartrate
    case 4: self = .sleep
    case 5: self = .stress
    case 6: self = .menstruation
    case 7: self = .breathe
    case 8: self = .alarms
    case 9: self = .phone
    case 10: self = .timers
    case 11: self = .stopwatch
    case 12: self = .spo2
    case 13: self = .weather
    case 14: self = .cameraRemote
    case 15: self = .music
    case 16: self = .findPhone
    case 17: self = .worldClock
    case 18: self = .settings
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .activity: return 0
    case .workout: return 1
    case .steps: return 2
    case .heartrate: return 3
    case .sleep: return 4
    case .stress: return 5
    case .menstruation: return 6
    case .breathe: return 7
    case .alarms: return 8
    case .phone: return 9
    case .timers: return 10
    case .stopwatch: return 11
    case .spo2: return 12
    case .weather: return 13
    case .cameraRemote: return 14
    case .music: return 15
    case .findPhone: return 16
    case .worldClock: return 17
    case .settings: return 18
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension app_list: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [app_list] = [
    .activity,
    .workout,
    .steps,
    .heartrate,
    .sleep,
    .stress,
    .menstruation,
    .breathe,
    .alarms,
    .phone,
    .timers,
    .stopwatch,
    .spo2,
    .weather,
    .cameraRemote,
    .music,
    .findPhone,
    .worldClock,
    .settings,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension operate_type: @unchecked Sendable {}
extension Platform: @unchecked Sendable {}
extension Shape: @unchecked Sendable {}
extension Dev_type: @unchecked Sendable {}
extension Batt_mode: @unchecked Sendable {}
extension Batt_status: @unchecked Sendable {}
extension disp_status: @unchecked Sendable {}
extension alarm_type: @unchecked Sendable {}
extension bind_method: @unchecked Sendable {}
extension bind_flag: @unchecked Sendable {}
extension bind_phone_type: @unchecked Sendable {}
extension call_status: @unchecked Sendable {}
extension quick_card_type: @unchecked Sendable {}
extension sync_type: @unchecked Sendable {}
extension sync_operate: @unchecked Sendable {}
extension language: @unchecked Sendable {}
extension log_operate_type: @unchecked Sendable {}
extension period_log: @unchecked Sendable {}
extension notify_type: @unchecked Sendable {}
extension health_monitor_mode: @unchecked Sendable {}
extension health_type: @unchecked Sendable {}
extension music_status: @unchecked Sendable {}
extension operate_II_type: @unchecked Sendable {}
extension sensor_operate_type: @unchecked Sendable {}
extension sleep_monitor_type: @unchecked Sendable {}
extension sport_type: @unchecked Sendable {}
extension interval_division_mode: @unchecked Sendable {}
extension gender_type: @unchecked Sendable {}
extension dial_type: @unchecked Sendable {}
extension dial_operate_type: @unchecked Sendable {}
extension weather_type: @unchecked Sendable {}
extension wind_direction_type: @unchecked Sendable {}
extension moon_phase: @unchecked Sendable {}
extension message_remind_type: @unchecked Sendable {}
extension notify_os_platform: @unchecked Sendable {}
extension aod_mode: @unchecked Sendable {}
extension event_id: @unchecked Sendable {}
extension long_2s_press_type: @unchecked Sendable {}
extension app_list: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension operate_type: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID"),
    1: .same(proto: "INQUIRE"),
    2: .same(proto: "SET"),
  ]
}

extension Platform: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "JX_3085C_PLATFORM"),
    1: .same(proto: "JX_3085L_PLATFORM"),
    2: .same(proto: "JX_3085E_PLATFORM"),
  ]
}

extension Shape: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SQUARE_SHAPE"),
    1: .same(proto: "ROUND_SHAPE"),
  ]
}

extension Dev_type: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WATCH_TYPE"),
    1: .same(proto: "BAND_TYPE"),
  ]
}

extension Batt_mode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_MODE"),
    1: .same(proto: "NORMAL_MODE"),
    2: .same(proto: "ECO_MODE"),
  ]
}

extension Batt_status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NORMAL"),
    1: .same(proto: "CHARING"),
    2: .same(proto: "FULL"),
    3: .same(proto: "LOW"),
  ]
}

extension disp_status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DISP_OFF"),
    1: .same(proto: "DISP_ON"),
  ]
}

extension alarm_type: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GET_UP"),
    1: .same(proto: "SLEEP"),
  ]
}

extension bind_method: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BIND_ENCRYPTED"),
    1: .same(proto: "BIND_NORMAL"),
    2: .same(proto: "BIND_REMOVE"),
    3: .same(proto: "BIND_PAIRING_CODE"),
  ]
}

extension bind_flag: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BIND_FLAG_REQUEST"),
    1: .same(proto: "BIND_FLAG_FAILED"),
    2: .same(proto: "BIND_FLAG_SUCCESS"),
    3: .same(proto: "BIND_FLAG_BOUND"),
  ]
}

extension bind_phone_type: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ANDROID"),
    1: .same(proto: "IOS"),
  ]
}

extension call_status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RECEIVED_CALL"),
    1: .same(proto: "REJECT_CALL"),
  ]
}

extension quick_card_type: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CARD_TYPE_EXERCISE"),
    1: .same(proto: "CARD_TYPE_WEATHER"),
    2: .same(proto: "CARD_TYPE_SUGGEST"),
    3: .same(proto: "CARD_TYPE_DIAL"),
    4: .same(proto: "CARD_TYPE_ACTIVITY"),
    5: .same(proto: "CARD_TYPE_HEARTRATE"),
    6: .same(proto: "CARD_TYPE_SLEEP"),
    7: .same(proto: "CARD_TYPE_STEPS"),
    8: .same(proto: "CARD_TYPE_SPO2"),
    9: .same(proto: "CARD_TYPE_MENSTRUATION"),
    10: .same(proto: "CARD_TYPE_MEASUREMENT"),
    11: .same(proto: "CARD_TYPE_RECENT_WORKOUT"),
    12: .same(proto: "CARD_TYPE_HRV"),
    13: .same(proto: "CARD_TYPE_UV"),
    14: .same(proto: "CARD_TYPE_ASTRONOMY"),
    15: .same(proto: "CARD_TYPE_WORLD_CLOCK"),
    16: .same(proto: "CARD_TYPE_ALEXA"),
  ]
}

extension sync_type: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SYNC_HEART_RATE"),
    1: .same(proto: "SYNC_STRESS"),
    2: .same(proto: "SYNC_SPO2"),
    3: .same(proto: "SYNC_SLEEP"),
    4: .same(proto: "SYNC_WORKOUT"),
    5: .same(proto: "SYNC_ACTIVITY"),
    6: .same(proto: "SYNC_SWIMMING"),
    7: .same(proto: "SYNC_GPS"),
    8: .same(proto: "SYNC_NOISE"),
    9: .same(proto: "SYNC_BODY_ENERGY"),
    10: .same(proto: "SYNC_RESPIRATORY_RATE"),
    11: .same(proto: "SYNC_SKIN_TEMPERATURE"),
  ]
}

extension sync_operate: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "START_SYNC"),
    1: .same(proto: "END_SYNC"),
  ]
}

extension language: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LANG_INVALID"),
    1: .same(proto: "CHINESE"),
    2: .same(proto: "ENGLISH"),
    3: .same(proto: "GERMAN"),
    4: .same(proto: "SPANISH"),
    5: .same(proto: "ITALIAN"),
    6: .same(proto: "JAPANESE"),
    7: .same(proto: "RUSSIAN"),
    8: .same(proto: "PORTUGUESE"),
    9: .same(proto: "FRENCH"),
    10: .same(proto: "KOREAN"),
    11: .same(proto: "POLISH"),
  ]
}

extension log_operate_type: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOG_START"),
    1: .same(proto: "LOG_END"),
  ]
}

extension period_log: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PERIOD_LOG_NULL"),
    1: .same(proto: "PERIOD_LOG_NOT_FLOW"),
    2: .same(proto: "PERIOD_LOG_AS_USUAL"),
    3: .same(proto: "PERIOD_LOG_LIGHT_FLOW"),
    4: .same(proto: "PERIOD_LOG_MENDIUM_FLOW"),
    5: .same(proto: "PERIOD_LOG_HEAVY_FLOW"),
  ]
}

extension notify_type: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW"),
    1: .same(proto: "SILENT"),
    2: .same(proto: "CLOSE"),
  ]
}

extension health_monitor_mode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MANUAL"),
    1: .same(proto: "AUTO"),
    2: .same(proto: "CONTINUOUS"),
    3: .same(proto: "INTELLIHENT"),
  ]
}

extension health_type: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HEART_RATE"),
    1: .same(proto: "STRESS"),
    2: .same(proto: "SPO2"),
    3: .same(proto: "NOISE"),
    4: .same(proto: "BODY_ENERGY"),
    5: .same(proto: "RESPIRATORY_RATE"),
    6: .same(proto: "SKIN_TEMPERATURE"),
  ]
}

extension music_status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MUSIC_STATUS_INVALID"),
    1: .same(proto: "MUSIC_STATUS_PLAY"),
    2: .same(proto: "MUSIC_STATUS_PAUSE"),
  ]
}

extension operate_II_type: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INSERT"),
    1: .same(proto: "DELETE"),
    2: .same(proto: "UPDATE"),
    3: .same(proto: "READ"),
  ]
}

extension sensor_operate_type: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SENSOR_TRAN_START"),
    1: .same(proto: "SENSOR_TRAN_END"),
    2: .same(proto: "OFF_LINE_TRAN_START"),
    3: .same(proto: "OFF_LINE_TRAN_END"),
  ]
}

extension sleep_monitor_type: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GENERAL"),
    1: .same(proto: "SCIENCE"),
  ]
}

extension sport_type: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ORUN"),
    1: .same(proto: "IRUN"),
    2: .same(proto: "OWALK"),
    3: .same(proto: "IWALK"),
    4: .same(proto: "HIKING"),
    5: .same(proto: "OCYCLE"),
    6: .same(proto: "ICYCLE"),
    7: .same(proto: "CRICKET"),
    8: .same(proto: "FOOTBALL"),
    9: .same(proto: "PSWIM"),
    10: .same(proto: "OSWIM"),
    11: .same(proto: "YOGA"),
    12: .same(proto: "PILATES"),
    13: .same(proto: "DANCE"),
    14: .same(proto: "ZUMBA"),
    15: .same(proto: "ROWER"),
    16: .same(proto: "ELLIPTICAL"),
    17: .same(proto: "CTRAINING"),
    18: .same(proto: "TSTRAINING"),
    19: .same(proto: "FSTRAINING"),
    20: .same(proto: "HIIT"),
    21: .same(proto: "COOLDOWN"),
    22: .same(proto: "WORKOUT"),
    23: .same(proto: "FITNESS"),
    24: .same(proto: "TRAIL_RUNNING"),
    25: .same(proto: "TREADMILL"),
    26: .same(proto: "AEROBICS"),
    27: .same(proto: "SIT_UP"),
    28: .same(proto: "PLANK"),
    29: .same(proto: "JUMPING_JACK"),
    30: .same(proto: "CHIN_UP"),
    31: .same(proto: "PUSH_UP"),
    32: .same(proto: "DEEP_SQUAT"),
    33: .same(proto: "HIGH_KNEE_LIFT"),
    34: .same(proto: "DUMBBELL"),
    35: .same(proto: "BARBELL"),
    36: .same(proto: "BOXING"),
    37: .same(proto: "KICKBOXING"),
    38: .same(proto: "HORIZONTAL_BAR"),
    39: .same(proto: "PARALLEL_BARS"),
    40: .same(proto: "WALKING_MACHINE"),
    41: .same(proto: "SUMMIT_TRAINERS"),
    42: .same(proto: "BOWLING"),
    43: .same(proto: "TENNIS"),
    44: .same(proto: "TABLE_TENNIS"),
    45: .same(proto: "GOLF"),
    46: .same(proto: "BASKETBALL"),
    47: .same(proto: "BADMINTON"),
    48: .same(proto: "HOCKEY"),
    49: .same(proto: "RUGBY"),
    50: .same(proto: "HANDBALL"),
    51: .same(proto: "SQUASH"),
    52: .same(proto: "BASEBALL"),
    53: .same(proto: "SOFTBALL"),
    54: .same(proto: "SHUTTLECOCK"),
    55: .same(proto: "SEPAKTAKRAW"),
    56: .same(proto: "STREET_DANCE"),
    57: .same(proto: "MOUNTAIN_CLINBING"),
    58: .same(proto: "ROPE_SKIPPING"),
    59: .same(proto: "CLIMB_STAIRS"),
    60: .same(proto: "BALLET"),
    61: .same(proto: "SOCIAL_DANCE"),
    62: .same(proto: "DARTS"),
    63: .same(proto: "HORSEBACK_RIDING"),
    64: .same(proto: "ROLLER_SKATING"),
    65: .same(proto: "TAI_CHI"),
    66: .same(proto: "FRISBEE"),
    67: .same(proto: "HULA_HOOP"),
    68: .same(proto: "SLEIGH"),
    69: .same(proto: "SKATING"),
    70: .same(proto: "BOBSLEIGH_AND_TOBOGGANING"),
    71: .same(proto: "CURLING"),
    72: .same(proto: "ICE_HOCKEY"),
    73: .same(proto: "SURFING"),
    74: .same(proto: "SAILBOAT"),
    75: .same(proto: "SAILBOARD"),
    76: .same(proto: "FOLDBOATING"),
    77: .same(proto: "CANOEING"),
    78: .same(proto: "BOAT_RACE"),
    79: .same(proto: "MOTORBOAT"),
    80: .same(proto: "WATER_POLO"),
    81: .same(proto: "SLIDING_PLATE"),
    82: .same(proto: "ROCK_CLIMBING"),
    83: .same(proto: "BUNGEE_JUMPING"),
    84: .same(proto: "PARKOUR"),
    85: .same(proto: "OTHER"),
    86: .same(proto: "SPINNING"),
    87: .same(proto: "MARTIAL_ARTS"),
    88: .same(proto: "TAEKWONDO"),
    89: .same(proto: "KARATE"),
    90: .same(proto: "GYMNASTICS"),
    91: .same(proto: "PADEL"),
    92: .same(proto: "PICKLEBALL"),
    93: .same(proto: "SNOWBOARDING"),
    94: .same(proto: "SKIING"),
    95: .same(proto: "PADDLING"),
    96: .same(proto: "BMX"),
    97: .same(proto: "FENCING"),
    98: .same(proto: "BILLIARDS"),
    99: .same(proto: "BEACH_SOCCER"),
    100: .same(proto: "BEACH_VOLLEYBALL"),
    101: .same(proto: "DODGEBALL"),
    102: .same(proto: "JAZZ"),
    103: .same(proto: "LATIN"),
    104: .same(proto: "SQUARE_DANCE"),
    105: .same(proto: "VOLLEYBALL"),
    106: .same(proto: "KITE_FLYING"),
    107: .same(proto: "FISHING"),
    108: .same(proto: "ARCHERY"),
    109: .same(proto: "SHOOTING"),
    110: .same(proto: "WHITE_WATER_RAFTING"),
    111: .same(proto: "ALPINE_SKIING"),
    112: .same(proto: "CROSS_COUNTRY_SKIING"),
    113: .same(proto: "BIATHON"),
    114: .same(proto: "DRAGON_BOAT_RACING"),
    115: .same(proto: "RACING"),
  ]
}

extension interval_division_mode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MAXIMUM_MODE"),
    1: .same(proto: "RESERVE_MODE"),
  ]
}

extension gender_type: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GENDER_MALE"),
    1: .same(proto: "GENDER_FEMALE"),
    2: .same(proto: "GENDER_OTHER"),
  ]
}

extension dial_type: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DIAL_TYPE_NULL"),
    1: .same(proto: "DIAL_TYPE_GENERAL"),
    2: .same(proto: "DIAL_TYPE_PHOTO"),
    3: .same(proto: "DIAL_TYPE_WALLPAPER"),
    4: .same(proto: "DIAL_TYPE_CUSTOM"),
    5: .same(proto: "DIAL_TYPE_GENERAL_AOD"),
    6: .same(proto: "DIAL_TYPE_AOD"),
  ]
}

extension dial_operate_type: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DIAL_OPERATE_TYPE_INQUIRE"),
    1: .same(proto: "DIAL_OPERATE_TYPE_SET"),
    2: .same(proto: "DIAL_OPERATE_TYPE_DELETE"),
  ]
}

extension weather_type: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TORNADO"),
    1: .same(proto: "TROPICAL_STORM"),
    2: .same(proto: "HURRICANE"),
    3: .same(proto: "STRONG_STORMS"),
    4: .same(proto: "THUNDERSTORMS"),
    5: .same(proto: "RAIN_SNOW"),
    6: .same(proto: "RAIN_SLEET"),
    7: .same(proto: "WINTRY_MIX"),
    8: .same(proto: "FREEZING_DRIZZLE"),
    9: .same(proto: "DRIZZLE"),
    10: .same(proto: "FREEZING_RAIN"),
    11: .same(proto: "SHOWERS"),
    12: .same(proto: "RAIN"),
    13: .same(proto: "FLURRIES"),
    14: .same(proto: "SNOW_SHOWERS"),
    15: .same(proto: "DRIFTING_SNOW"),
    16: .same(proto: "SNOW"),
    17: .same(proto: "HAIL"),
    18: .same(proto: "SLEET"),
    19: .same(proto: "BLOWING_DUST_SANDSTORM"),
    20: .same(proto: "FOGGY"),
    21: .same(proto: "HAZE"),
    22: .same(proto: "SMOKE"),
    23: .same(proto: "BREEZY"),
    24: .same(proto: "WINDY"),
    25: .same(proto: "ICE_CRYSTALS"),
    26: .same(proto: "CLOUDY"),
    27: .same(proto: "MOSTLY_CLOUDY_NIGHT"),
    28: .same(proto: "MOSTLY_CLOUDY_DAY"),
    29: .same(proto: "PARTLY_CLOUDY_NIGHT"),
    30: .same(proto: "PARTLY_CLOUDY_DAY"),
    31: .same(proto: "CLEAR"),
    32: .same(proto: "SUNNY"),
    33: .same(proto: "MOSTLY_CLEAR"),
    34: .same(proto: "MOSTLY_SUNNY"),
    35: .same(proto: "MIXED_RAIN_HAIL"),
    36: .same(proto: "HOt"),
    37: .same(proto: "ISOLATED_THUNDERSTORMS"),
    38: .same(proto: "SCATTERED_THUNDERSTORMS_D"),
    39: .same(proto: "SCATTERED_SHOWERS_NIGHT"),
    40: .same(proto: "HEAVY_RAIN"),
    41: .same(proto: "SCATTERED_SNOW_SHOWERS_D"),
    42: .same(proto: "HEAVY_SNOW"),
    43: .same(proto: "BLIZZARD"),
    44: .same(proto: "NOT_AVAILABLE"),
    45: .same(proto: "SCATTERED_SNOW_SHOWERS_N"),
    46: .same(proto: "SCATTERED_SHOWERS"),
    47: .same(proto: "SCATTERED_THUNDERSTORMS_N"),
  ]
}

extension wind_direction_type: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WEATHER_DIRECTION_N"),
    1: .same(proto: "WEATHER_DIRECTION_NNE"),
    2: .same(proto: "WEATHER_DIRECTION_NE"),
    3: .same(proto: "WEATHER_DIRECTION_ENE"),
    4: .same(proto: "WEATHER_DIRECTION_E"),
    5: .same(proto: "WEATHER_DIRECTION_ESE"),
    6: .same(proto: "WEATHER_DIRECTION_SE"),
    7: .same(proto: "WEATHER_DIRECTION_SSE"),
    8: .same(proto: "WEATHER_DIRECTION_S"),
    9: .same(proto: "WEATHER_DIRECTION_SSW"),
    10: .same(proto: "WEATHER_DIRECTION_SW"),
    11: .same(proto: "WEATHER_DIRECTION_WSW"),
    12: .same(proto: "WEATHER_DIRECTION_W"),
    13: .same(proto: "WEATHER_DIRECTION_WNWM"),
    14: .same(proto: "WEATHER_DIRECTION_NW"),
    15: .same(proto: "WEATHER_DIRECTION_NNW"),
  ]
}

extension moon_phase: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NEW_MOON"),
    1: .same(proto: "WAXING_CRESCENT"),
    2: .same(proto: "FIRST_QUARTER"),
    3: .same(proto: "WAXING_GIBBOUS"),
    4: .same(proto: "FULL_MOON"),
    5: .same(proto: "WANING_GIBBOUS"),
    6: .same(proto: "LAST_QUARTER"),
    7: .same(proto: "WANING_MOON"),
  ]
}

extension message_remind_type: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NULL"),
    1: .same(proto: "SMS"),
    2: .same(proto: "Email"),
    3: .same(proto: "Calendar"),
    4: .same(proto: "Missed_Call"),
    5: .same(proto: "Facebook"),
    6: .same(proto: "Twitter"),
    7: .same(proto: "Instagram"),
    8: .same(proto: "Snapchat"),
    9: .same(proto: "Whatsapp"),
    10: .same(proto: "Line"),
    11: .same(proto: "Tiktok"),
    12: .same(proto: "Skype"),
    13: .same(proto: "Wechat"),
    14: .same(proto: "Fitbeing"),
    15: .same(proto: "Microsoft_Teams"),
    16: .same(proto: "Telegram_Messenger"),
    17: .same(proto: "Messenger"),
    18: .same(proto: "LinkedIn"),
    19: .same(proto: "Gmail"),
    20: .same(proto: "Microsoft_Outlook"),
    21: .same(proto: "Google_Chat"),
    22: .same(proto: "QQ"),
    23: .same(proto: "WhatsApp_Business"),
    24: .same(proto: "Youtube"),
    25: .same(proto: "Uber"),
    26: .same(proto: "Uber_eats"),
    27: .same(proto: "Door_Dash_missing"),
    28: .same(proto: "Banco_General"),
    29: .same(proto: "BAC_Bank"),
    30: .same(proto: "Google_Maps"),
    31: .same(proto: "Amazon_shopping"),
    32: .same(proto: "Spotify"),
    33: .same(proto: "Discord"),
    34: .same(proto: "OHTER"),
  ]
}

extension notify_os_platform: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ANDROID_NOTIFY"),
    1: .same(proto: "IOS_NOTIFY"),
  ]
}

extension aod_mode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INTELLIGENT_MODE"),
    1: .same(proto: "TIMER_MDOE"),
  ]
}

extension event_id: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EVENT_ID_NULL"),
    1: .same(proto: "EVENT_ID_MUSIC_CONTROL"),
    2: .same(proto: "EVENT_ID_FIND_PHONE"),
    3: .same(proto: "EVENT_ID_SYNC_DATA"),
    4: .same(proto: "EVENT_ID_FIND_WATCH"),
    5: .same(proto: "EVENT_ID_VOLUME_CHANGE"),
  ]
}

extension long_2s_press_type: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRESS_TYPE_NULL"),
    1: .same(proto: "PRESS_TYPE_SOS"),
    2: .same(proto: "PRESS_TYPE_WORKOUT"),
    3: .same(proto: "PRESS_TYPE_ALEXA"),
  ]
}

extension app_list: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "APP_LIST_ACTIVITY"),
    1: .same(proto: "APP_LIST_WORKOUT"),
    2: .same(proto: "APP_LIST_STEPS"),
    3: .same(proto: "APP_LIST_HEARTRATE"),
    4: .same(proto: "APP_LIST_SLEEP"),
    5: .same(proto: "APP_LIST_STRESS"),
    6: .same(proto: "APP_LIST_MENSTRUATION"),
    7: .same(proto: "APP_LIST_BREATHE"),
    8: .same(proto: "APP_LIST_ALARMS"),
    9: .same(proto: "APP_LIST_PHONE"),
    10: .same(proto: "APP_LIST_TIMERS"),
    11: .same(proto: "APP_LIST_STOPWATCH"),
    12: .same(proto: "APP_LIST_SPO2"),
    13: .same(proto: "APP_LIST_WEATHER"),
    14: .same(proto: "APP_LIST_CAMERA_REMOTE"),
    15: .same(proto: "APP_LIST_MUSIC"),
    16: .same(proto: "APP_LIST_FIND_PHONE"),
    17: .same(proto: "APP_LIST_WORLD_CLOCK"),
    18: .same(proto: "APP_LIST_SETTINGS"),
  ]
}
