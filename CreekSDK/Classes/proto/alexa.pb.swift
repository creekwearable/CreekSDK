// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: alexa.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct protocol_alexa_tran_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tranType: tran_direction_type = .watchTran

  ///alexa 传输操作
  public var operate: alexa_operate_type = .alexaOperateNull

  ///0 正常 非0失败
  public var errCode: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_alexa_status_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 传输类型 0：无效操作 1：手表发起 2：app发起
  public var tranType: tran_direction_type = .watchTran

  ///通知类型
  public var noticeType: alexa_noitce_type = .alexaNoticeNull

  ///状态类型
  public var statusType: alexa_status_type = .alexaStatusNull

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_alexa_result_operate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///是否问句
  public var isQuestion: Bool = false

  ///max:1000 结果内容
  public var content: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

////闹钟
public struct alexa_alarm_item: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///2bytes
  public var year: UInt32 = 0

  ///1bytes
  public var month: UInt32 = 0

  ///1bytes
  public var day: UInt32 = 0

  ///1bytes
  public var hour: UInt32 = 0

  ///1bytes
  public var minute: UInt32 = 0

  ///1bytes 开关
  public var switchFlag: Bool = false

  ///7bytes 重复 周一~周七
  public var `repeat`: [Bool] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_alexa_alarm_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///max：5 闹钟列表
  public var alarmItem: [alexa_alarm_item] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_alexa_alarm_inquire_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///1bytes 功能表
  public var funcTable: UInt32 = 0

  ///1bytes 闹钟支持最大数量
  public var alarmSupportMax: UInt32 = 0

  ///max：5 闹钟列表
  public var alarmItem: [alexa_alarm_item] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct alexa_reminder_item: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///2bytes
  public var year: UInt32 = 0

  ///1bytes
  public var month: UInt32 = 0

  ///1bytes
  public var day: UInt32 = 0

  ///1bytes
  public var hour: UInt32 = 0

  ///1bytes
  public var minute: UInt32 = 0

  ///max:50 内容
  public var content: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_alexa_reminder_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///max：5 提醒列表
  public var reminderItem: [alexa_reminder_item] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_alexa_reminder_inquire_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///1bytes 功能表
  public var funcTable: UInt32 = 0

  ///1bytes 提醒支持最大数量
  public var reminderSupportMax: UInt32 = 0

  ///max：5 提醒列表
  public var reminderItem: [alexa_reminder_item] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct alexa_timer_item: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var index: UInt32 = 0

  public var timerSec: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_alexa_timer_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///定时器操作
  public var timerOperate: alexa_timer_operate = .alexaTimerInsert

  ///定时器编号
  public var index: UInt32 = 0

  ///定时时间 单位秒
  public var timerSec: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_alexa_timer_inquire_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///1bytes 功能表
  public var funcTable: UInt32 = 0

  ///1bytes 提醒支持最大数量
  public var timerSupportMax: UInt32 = 0

  ///定时器列表
  public var items: [alexa_timer_item] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct alexa_weather_future_item: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 天气类型
  public var weatherType: Data = Data()

  ///1bytes 最大温度
  public var maxTemp: Int32 = 0

  ///1bytes 最小温度
  public var minTemp: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct alexa_weather_detail_data_item: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///最新同步
  public var year: UInt32 = 0

  /// 月份
  public var month: UInt32 = 0

  public var day: UInt32 = 0

  ///时
  public var hour: UInt32 = 0

  ///分
  public var min: UInt32 = 0

  ///1bytes 星期  0x00无效 0x01~0x07:星期一~星期日
  public var week: UInt32 = 0

  /// 天气类型
  public var weatherType: Data = Data()

  ///1bytes 当前的温度
  public var curTemp: Int32 = 0

  ///1bytes 最大温度
  public var curMaxTemp: Int32 = 0

  ///1bytes 最小温度
  public var curMinTemp: Int32 = 0

  ///max:60 城市名称
  public var cityName: Data = Data()

  ///最近七天天气
  public var futureItems: [alexa_weather_future_item] = []

  ///温度单位，0：摄氏度，1：华氏度
  public var tempUnit: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_alexa_weather_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  public var detailDataItem: alexa_weather_detail_data_item {
    get {return _detailDataItem ?? alexa_weather_detail_data_item()}
    set {_detailDataItem = newValue}
  }
  /// Returns true if `detailDataItem` has been explicitly set.
  public var hasDetailDataItem: Bool {return self._detailDataItem != nil}
  /// Clears the value of `detailDataItem`. Subsequent reads from it will return its default value.
  public mutating func clearDetailDataItem() {self._detailDataItem = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _detailDataItem: alexa_weather_detail_data_item? = nil
}

public struct protocol_alexa_weather_inquire_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///1bytes 功能表
  public var funcTable: UInt32 = 0

  ///1bytes 天气详情支持最大数量
  public var weatherSupportMax: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

////通知
public struct protocol_alexa_notify_status_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///通知状态
  public var notifyStatus: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_alexa_notify_status_inquire_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///通知状态
  public var notifyStatus: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///alexa开关
public struct protocol_alexa_config_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///该地区是否支持alexa
  public var alexaSupport: Bool = false

  ///alexa设置开关
  public var alexaSwitch: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_alexa_config_inquire_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///alexa设置开关
  public var alexaSwitch: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_voice_assistant_tran_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tranType: tran_direction_type = .watchTran

  /// 传输操作
  public var operate: voice_assistant_operate_type = .aiOperateNull

  ///0 正常 非0失败
  public var errCode: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_voice_assistant_status_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 传输类型 0：无效操作 1：手表发起 2：app发起
  public var tranType: tran_direction_type = .watchTran

  ///通知类型
  public var noticeType: voice_assistant_noitce_type = .aiNoticeNull

  ///状态类型
  public var statusType: voice_assistant_status_type = .aiStatusNull

  ///对话类型
  public var dialogType: voice_assistant_dialog_type = .aiDialogNormal

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_voice_assistant_result_operate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///是否问句
  public var isQuestion: Bool = false

  ///回显索引，新语句从1开始
  public var echoIndex: UInt32 = 0

  ///max:1000 回显内容，支持拼接
  public var echoContent: Data = Data()

  ///结果索引，新语句从1开始
  public var answerIndex: UInt32 = 0

  ///max:1000 结果内容，支持拼接
  public var answerContent: Data = Data()

  ///自己名字
  public var ownName: Data = Data()

  ///对话名字
  public var talkName: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_voice_assistant_function_table: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///enum voice_assistant_status_type,支持超时退出ai
  public var aiStatusTimeoutExit: Bool = false

  ///版本号
  public var version: UInt32 = 0

  ///是否支持打字机效果
  public var aiTypewriterEffectSupport: Bool = false

  ///支持应用跳转
  public var aiApplicationSkillSupport: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_voice_assistant_dial_operate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 传输类型 0：无效操作 1：手表发起 2：app发
  public var tranType: tran_direction_type = .watchTran

  ///文本类型
  public var dialType: voice_assistant_dial_type = .aiDialNull

  ///文本
  public var extraInfo: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_voice_assistant_string_operate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 传输类型 0：无效操作 1：手表发起 2：app发
  public var tranType: tran_direction_type = .watchTran

  ///文本类型
  public var stringType: voice_assistant_string_type = .aiStringNull

  ///文本
  public var extraInfo: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_translation_assistant_config_info_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 传输类型 0：无效操作 1：手表发起 2：app发起
  public var tranType: tran_direction_type = .watchTran

  ///枚举引用语言协议 main_id:0x04
  public var currentLanguage: language = .langInvalid

  public var targetLanguage: language = .langInvalid

  ///语速
  public var speed: ai_translate_speed_level = .aiTranslateSpeedUnknown

  ///自动播报 0关闭1开启
  public var autoPronounce: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_translation_assistant_result_operate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///回显索引，新语句从1开始
  public var echoIndex: UInt32 = 0

  ///max:1000 回显内容，支持拼接
  public var echoContent: Data = Data()

  /// 结束识别
  public var endRecognition: Bool = false

  ///翻译语音识别的语言
  public var currentLanguage: language = .langInvalid

  ///结果索引，新语句从1开始
  public var answerIndex: UInt32 = 0

  ///max:1000 结果内容，支持拼接
  public var answerContent: Data = Data()

  /// 结果结束识别
  public var answerEndRecognition: Bool = false

  ///翻译结果识别的语言,枚举引用语言协议 main_id:0x04
  public var targetLanguage: language = .langInvalid

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_translation_assistant_manual_send_operate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 传输类型 0：无效操作 1：手表发起 2：app发起
  public var tranType: tran_direction_type = .watchTran

  public var targetLanguage: language = .langInvalid

  ///文本
  public var extraInfo: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_ai_feature_config: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户唯一标识
  public var userCode: Data = Data()

  /// 生效开始时间（timestamp, 秒）
  public var startTime: UInt32 = 0

  /// 生效结束时间（timestamp, 秒）
  public var endTime: UInt32 = 0

  /// 当前是否订阅（一期不做 validation）
  public var isSubscribed: Bool = false

  /// 是否支持会员机制（仅用于 UI 区分）
  public var isSubscriptionSupported: Bool = false

  /// 每日调用上限
  public var dailyCallLimit: UInt32 = 0

  /// 最大调用上限
  public var totalAllowedLimit: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_ai_feature_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 操作类型：查询 / 设置
  public var operate: operate_type = .invalid

  public var config: protocol_ai_feature_config {
    get {return _config ?? protocol_ai_feature_config()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {self._config = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _config: protocol_ai_feature_config? = nil
}

public struct protocol_ai_feature_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 操作类型：查询 / 设置
  public var operate: operate_type = .invalid

  public var config: protocol_ai_feature_config {
    get {return _config ?? protocol_ai_feature_config()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {self._config = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _config: protocol_ai_feature_config? = nil
}

public struct ai_feature_local_status: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 当前手表本地时间（由手机控制）
  public var systemTime: UInt32 = 0

  /// 当日已使用次数（跨天需固件主动刷新）
  public var dailyCount: UInt32 = 0

  /// 累计使用次数（仅 App 触发 SDK 后更新）
  public var totalCount: UInt32 = 0

  /// 每日调用上限
  public var dailyCallLimit: UInt32 = 0

  /// 最大调用上限
  public var totalAllowedLimit: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_ai_feature_notify_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 传输类型
  public var tranType: tran_direction_type = .watchTran

  public var type: ai_feature_type = .updataConfig

  ///使用状态
  public var status: ai_feature_local_status {
    get {return _status ?? ai_feature_local_status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: ai_feature_local_status? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension protocol_alexa_tran_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_tran_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tran_type"),
    2: .same(proto: "operate"),
    3: .standard(proto: "err_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.tranType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.errCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tranType != .watchTran {
      try visitor.visitSingularEnumField(value: self.tranType, fieldNumber: 1)
    }
    if self.operate != .alexaOperateNull {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 2)
    }
    if self.errCode != 0 {
      try visitor.visitSingularUInt32Field(value: self.errCode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_tran_operate, rhs: protocol_alexa_tran_operate) -> Bool {
    if lhs.tranType != rhs.tranType {return false}
    if lhs.operate != rhs.operate {return false}
    if lhs.errCode != rhs.errCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_status_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_status_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tran_type"),
    2: .standard(proto: "notice_type"),
    3: .standard(proto: "status_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.tranType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.noticeType) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.statusType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tranType != .watchTran {
      try visitor.visitSingularEnumField(value: self.tranType, fieldNumber: 1)
    }
    if self.noticeType != .alexaNoticeNull {
      try visitor.visitSingularEnumField(value: self.noticeType, fieldNumber: 2)
    }
    if self.statusType != .alexaStatusNull {
      try visitor.visitSingularEnumField(value: self.statusType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_status_operate, rhs: protocol_alexa_status_operate) -> Bool {
    if lhs.tranType != rhs.tranType {return false}
    if lhs.noticeType != rhs.noticeType {return false}
    if lhs.statusType != rhs.statusType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_result_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_result_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "is_question"),
    3: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isQuestion) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.isQuestion != false {
      try visitor.visitSingularBoolField(value: self.isQuestion, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_result_operate, rhs: protocol_alexa_result_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.isQuestion != rhs.isQuestion {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension alexa_alarm_item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "alexa_alarm_item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "year"),
    2: .same(proto: "month"),
    3: .same(proto: "day"),
    4: .same(proto: "hour"),
    5: .same(proto: "minute"),
    6: .standard(proto: "switch_flag"),
    7: .same(proto: "repeat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.year) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.month) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.day) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.hour) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.minute) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.switchFlag) }()
      case 7: try { try decoder.decodeRepeatedBoolField(value: &self.`repeat`) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.year != 0 {
      try visitor.visitSingularUInt32Field(value: self.year, fieldNumber: 1)
    }
    if self.month != 0 {
      try visitor.visitSingularUInt32Field(value: self.month, fieldNumber: 2)
    }
    if self.day != 0 {
      try visitor.visitSingularUInt32Field(value: self.day, fieldNumber: 3)
    }
    if self.hour != 0 {
      try visitor.visitSingularUInt32Field(value: self.hour, fieldNumber: 4)
    }
    if self.minute != 0 {
      try visitor.visitSingularUInt32Field(value: self.minute, fieldNumber: 5)
    }
    if self.switchFlag != false {
      try visitor.visitSingularBoolField(value: self.switchFlag, fieldNumber: 6)
    }
    if !self.`repeat`.isEmpty {
      try visitor.visitPackedBoolField(value: self.`repeat`, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: alexa_alarm_item, rhs: alexa_alarm_item) -> Bool {
    if lhs.year != rhs.year {return false}
    if lhs.month != rhs.month {return false}
    if lhs.day != rhs.day {return false}
    if lhs.hour != rhs.hour {return false}
    if lhs.minute != rhs.minute {return false}
    if lhs.switchFlag != rhs.switchFlag {return false}
    if lhs.`repeat` != rhs.`repeat` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_alarm_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_alarm_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "alarm_item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.alarmItem) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if !self.alarmItem.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.alarmItem, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_alarm_operate, rhs: protocol_alexa_alarm_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.alarmItem != rhs.alarmItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_alarm_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_alarm_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "func_table"),
    3: .standard(proto: "alarm_support_max"),
    4: .standard(proto: "alarm_item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.funcTable) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.alarmSupportMax) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.alarmItem) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.funcTable != 0 {
      try visitor.visitSingularUInt32Field(value: self.funcTable, fieldNumber: 2)
    }
    if self.alarmSupportMax != 0 {
      try visitor.visitSingularUInt32Field(value: self.alarmSupportMax, fieldNumber: 3)
    }
    if !self.alarmItem.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.alarmItem, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_alarm_inquire_reply, rhs: protocol_alexa_alarm_inquire_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.funcTable != rhs.funcTable {return false}
    if lhs.alarmSupportMax != rhs.alarmSupportMax {return false}
    if lhs.alarmItem != rhs.alarmItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension alexa_reminder_item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "alexa_reminder_item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "year"),
    2: .same(proto: "month"),
    3: .same(proto: "day"),
    4: .same(proto: "hour"),
    5: .same(proto: "minute"),
    6: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.year) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.month) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.day) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.hour) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.minute) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.year != 0 {
      try visitor.visitSingularUInt32Field(value: self.year, fieldNumber: 1)
    }
    if self.month != 0 {
      try visitor.visitSingularUInt32Field(value: self.month, fieldNumber: 2)
    }
    if self.day != 0 {
      try visitor.visitSingularUInt32Field(value: self.day, fieldNumber: 3)
    }
    if self.hour != 0 {
      try visitor.visitSingularUInt32Field(value: self.hour, fieldNumber: 4)
    }
    if self.minute != 0 {
      try visitor.visitSingularUInt32Field(value: self.minute, fieldNumber: 5)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: alexa_reminder_item, rhs: alexa_reminder_item) -> Bool {
    if lhs.year != rhs.year {return false}
    if lhs.month != rhs.month {return false}
    if lhs.day != rhs.day {return false}
    if lhs.hour != rhs.hour {return false}
    if lhs.minute != rhs.minute {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_reminder_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_reminder_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "reminder_item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.reminderItem) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if !self.reminderItem.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reminderItem, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_reminder_operate, rhs: protocol_alexa_reminder_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.reminderItem != rhs.reminderItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_reminder_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_reminder_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "func_table"),
    3: .standard(proto: "reminder_support_max"),
    4: .standard(proto: "reminder_item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.funcTable) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.reminderSupportMax) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.reminderItem) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.funcTable != 0 {
      try visitor.visitSingularUInt32Field(value: self.funcTable, fieldNumber: 2)
    }
    if self.reminderSupportMax != 0 {
      try visitor.visitSingularUInt32Field(value: self.reminderSupportMax, fieldNumber: 3)
    }
    if !self.reminderItem.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reminderItem, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_reminder_inquire_reply, rhs: protocol_alexa_reminder_inquire_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.funcTable != rhs.funcTable {return false}
    if lhs.reminderSupportMax != rhs.reminderSupportMax {return false}
    if lhs.reminderItem != rhs.reminderItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension alexa_timer_item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "alexa_timer_item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .standard(proto: "timer_sec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.timerSec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    if self.timerSec != 0 {
      try visitor.visitSingularUInt32Field(value: self.timerSec, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: alexa_timer_item, rhs: alexa_timer_item) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.timerSec != rhs.timerSec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_timer_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_timer_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "timer_operate"),
    3: .same(proto: "index"),
    4: .standard(proto: "timer_sec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.timerOperate) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.timerSec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.timerOperate != .alexaTimerInsert {
      try visitor.visitSingularEnumField(value: self.timerOperate, fieldNumber: 2)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 3)
    }
    if self.timerSec != 0 {
      try visitor.visitSingularUInt32Field(value: self.timerSec, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_timer_operate, rhs: protocol_alexa_timer_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.timerOperate != rhs.timerOperate {return false}
    if lhs.index != rhs.index {return false}
    if lhs.timerSec != rhs.timerSec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_timer_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_timer_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "func_table"),
    3: .standard(proto: "timer_support_max"),
    4: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.funcTable) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.timerSupportMax) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.funcTable != 0 {
      try visitor.visitSingularUInt32Field(value: self.funcTable, fieldNumber: 2)
    }
    if self.timerSupportMax != 0 {
      try visitor.visitSingularUInt32Field(value: self.timerSupportMax, fieldNumber: 3)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_timer_inquire_reply, rhs: protocol_alexa_timer_inquire_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.funcTable != rhs.funcTable {return false}
    if lhs.timerSupportMax != rhs.timerSupportMax {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension alexa_weather_future_item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "alexa_weather_future_item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "weather_type"),
    2: .standard(proto: "max_temp"),
    3: .standard(proto: "min_temp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.weatherType) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxTemp) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.minTemp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.weatherType.isEmpty {
      try visitor.visitSingularBytesField(value: self.weatherType, fieldNumber: 1)
    }
    if self.maxTemp != 0 {
      try visitor.visitSingularInt32Field(value: self.maxTemp, fieldNumber: 2)
    }
    if self.minTemp != 0 {
      try visitor.visitSingularInt32Field(value: self.minTemp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: alexa_weather_future_item, rhs: alexa_weather_future_item) -> Bool {
    if lhs.weatherType != rhs.weatherType {return false}
    if lhs.maxTemp != rhs.maxTemp {return false}
    if lhs.minTemp != rhs.minTemp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension alexa_weather_detail_data_item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "alexa_weather_detail_data_item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "year"),
    2: .same(proto: "month"),
    3: .same(proto: "day"),
    4: .same(proto: "hour"),
    5: .same(proto: "min"),
    6: .same(proto: "week"),
    7: .standard(proto: "weather_type"),
    8: .standard(proto: "cur_temp"),
    9: .standard(proto: "cur_max_temp"),
    10: .standard(proto: "cur_min_temp"),
    11: .standard(proto: "city_name"),
    12: .standard(proto: "future_items"),
    13: .standard(proto: "temp_unit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.year) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.month) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.day) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.hour) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.min) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.week) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.weatherType) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.curTemp) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.curMaxTemp) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.curMinTemp) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self.cityName) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.futureItems) }()
      case 13: try { try decoder.decodeSingularUInt32Field(value: &self.tempUnit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.year != 0 {
      try visitor.visitSingularUInt32Field(value: self.year, fieldNumber: 1)
    }
    if self.month != 0 {
      try visitor.visitSingularUInt32Field(value: self.month, fieldNumber: 2)
    }
    if self.day != 0 {
      try visitor.visitSingularUInt32Field(value: self.day, fieldNumber: 3)
    }
    if self.hour != 0 {
      try visitor.visitSingularUInt32Field(value: self.hour, fieldNumber: 4)
    }
    if self.min != 0 {
      try visitor.visitSingularUInt32Field(value: self.min, fieldNumber: 5)
    }
    if self.week != 0 {
      try visitor.visitSingularUInt32Field(value: self.week, fieldNumber: 6)
    }
    if !self.weatherType.isEmpty {
      try visitor.visitSingularBytesField(value: self.weatherType, fieldNumber: 7)
    }
    if self.curTemp != 0 {
      try visitor.visitSingularInt32Field(value: self.curTemp, fieldNumber: 8)
    }
    if self.curMaxTemp != 0 {
      try visitor.visitSingularInt32Field(value: self.curMaxTemp, fieldNumber: 9)
    }
    if self.curMinTemp != 0 {
      try visitor.visitSingularInt32Field(value: self.curMinTemp, fieldNumber: 10)
    }
    if !self.cityName.isEmpty {
      try visitor.visitSingularBytesField(value: self.cityName, fieldNumber: 11)
    }
    if !self.futureItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.futureItems, fieldNumber: 12)
    }
    if self.tempUnit != 0 {
      try visitor.visitSingularUInt32Field(value: self.tempUnit, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: alexa_weather_detail_data_item, rhs: alexa_weather_detail_data_item) -> Bool {
    if lhs.year != rhs.year {return false}
    if lhs.month != rhs.month {return false}
    if lhs.day != rhs.day {return false}
    if lhs.hour != rhs.hour {return false}
    if lhs.min != rhs.min {return false}
    if lhs.week != rhs.week {return false}
    if lhs.weatherType != rhs.weatherType {return false}
    if lhs.curTemp != rhs.curTemp {return false}
    if lhs.curMaxTemp != rhs.curMaxTemp {return false}
    if lhs.curMinTemp != rhs.curMinTemp {return false}
    if lhs.cityName != rhs.cityName {return false}
    if lhs.futureItems != rhs.futureItems {return false}
    if lhs.tempUnit != rhs.tempUnit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_weather_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_weather_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "detail_data_item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._detailDataItem) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    try { if let v = self._detailDataItem {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_weather_operate, rhs: protocol_alexa_weather_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs._detailDataItem != rhs._detailDataItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_weather_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_weather_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "func_table"),
    3: .standard(proto: "weather_support_max"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.funcTable) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.weatherSupportMax) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.funcTable != 0 {
      try visitor.visitSingularUInt32Field(value: self.funcTable, fieldNumber: 2)
    }
    if self.weatherSupportMax != 0 {
      try visitor.visitSingularUInt32Field(value: self.weatherSupportMax, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_weather_inquire_reply, rhs: protocol_alexa_weather_inquire_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.funcTable != rhs.funcTable {return false}
    if lhs.weatherSupportMax != rhs.weatherSupportMax {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_notify_status_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_notify_status_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "notify_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.notifyStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.notifyStatus != false {
      try visitor.visitSingularBoolField(value: self.notifyStatus, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_notify_status_operate, rhs: protocol_alexa_notify_status_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.notifyStatus != rhs.notifyStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_notify_status_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_notify_status_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "notify_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.notifyStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.notifyStatus != false {
      try visitor.visitSingularBoolField(value: self.notifyStatus, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_notify_status_inquire_reply, rhs: protocol_alexa_notify_status_inquire_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.notifyStatus != rhs.notifyStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_config_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_config_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "alexa_support"),
    3: .standard(proto: "alexa_switch"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.alexaSupport) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.alexaSwitch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.alexaSupport != false {
      try visitor.visitSingularBoolField(value: self.alexaSupport, fieldNumber: 2)
    }
    if self.alexaSwitch != false {
      try visitor.visitSingularBoolField(value: self.alexaSwitch, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_config_operate, rhs: protocol_alexa_config_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.alexaSupport != rhs.alexaSupport {return false}
    if lhs.alexaSwitch != rhs.alexaSwitch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_config_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_config_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "alexa_switch"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.alexaSwitch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.alexaSwitch != false {
      try visitor.visitSingularBoolField(value: self.alexaSwitch, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_config_inquire_reply, rhs: protocol_alexa_config_inquire_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.alexaSwitch != rhs.alexaSwitch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_voice_assistant_tran_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_voice_assistant_tran_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tran_type"),
    2: .same(proto: "operate"),
    3: .standard(proto: "err_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.tranType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.errCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tranType != .watchTran {
      try visitor.visitSingularEnumField(value: self.tranType, fieldNumber: 1)
    }
    if self.operate != .aiOperateNull {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 2)
    }
    if self.errCode != 0 {
      try visitor.visitSingularUInt32Field(value: self.errCode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_voice_assistant_tran_operate, rhs: protocol_voice_assistant_tran_operate) -> Bool {
    if lhs.tranType != rhs.tranType {return false}
    if lhs.operate != rhs.operate {return false}
    if lhs.errCode != rhs.errCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_voice_assistant_status_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_voice_assistant_status_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tran_type"),
    2: .standard(proto: "notice_type"),
    3: .standard(proto: "status_type"),
    4: .standard(proto: "dialog_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.tranType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.noticeType) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.statusType) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.dialogType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tranType != .watchTran {
      try visitor.visitSingularEnumField(value: self.tranType, fieldNumber: 1)
    }
    if self.noticeType != .aiNoticeNull {
      try visitor.visitSingularEnumField(value: self.noticeType, fieldNumber: 2)
    }
    if self.statusType != .aiStatusNull {
      try visitor.visitSingularEnumField(value: self.statusType, fieldNumber: 3)
    }
    if self.dialogType != .aiDialogNormal {
      try visitor.visitSingularEnumField(value: self.dialogType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_voice_assistant_status_operate, rhs: protocol_voice_assistant_status_operate) -> Bool {
    if lhs.tranType != rhs.tranType {return false}
    if lhs.noticeType != rhs.noticeType {return false}
    if lhs.statusType != rhs.statusType {return false}
    if lhs.dialogType != rhs.dialogType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_voice_assistant_result_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_voice_assistant_result_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "is_question"),
    3: .standard(proto: "echo_index"),
    4: .standard(proto: "echo_content"),
    5: .standard(proto: "answer_index"),
    6: .standard(proto: "answer_content"),
    7: .standard(proto: "own_name"),
    8: .standard(proto: "talk_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isQuestion) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.echoIndex) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.echoContent) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.answerIndex) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.answerContent) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.ownName) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.talkName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.isQuestion != false {
      try visitor.visitSingularBoolField(value: self.isQuestion, fieldNumber: 2)
    }
    if self.echoIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.echoIndex, fieldNumber: 3)
    }
    if !self.echoContent.isEmpty {
      try visitor.visitSingularBytesField(value: self.echoContent, fieldNumber: 4)
    }
    if self.answerIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.answerIndex, fieldNumber: 5)
    }
    if !self.answerContent.isEmpty {
      try visitor.visitSingularBytesField(value: self.answerContent, fieldNumber: 6)
    }
    if !self.ownName.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownName, fieldNumber: 7)
    }
    if !self.talkName.isEmpty {
      try visitor.visitSingularBytesField(value: self.talkName, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_voice_assistant_result_operate, rhs: protocol_voice_assistant_result_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.isQuestion != rhs.isQuestion {return false}
    if lhs.echoIndex != rhs.echoIndex {return false}
    if lhs.echoContent != rhs.echoContent {return false}
    if lhs.answerIndex != rhs.answerIndex {return false}
    if lhs.answerContent != rhs.answerContent {return false}
    if lhs.ownName != rhs.ownName {return false}
    if lhs.talkName != rhs.talkName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_voice_assistant_function_table: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_voice_assistant_function_table"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ai_status_timeout_exit"),
    2: .same(proto: "version"),
    3: .standard(proto: "ai_typewriter_effect_support"),
    4: .standard(proto: "ai_application_skill_support"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.aiStatusTimeoutExit) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.aiTypewriterEffectSupport) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.aiApplicationSkillSupport) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.aiStatusTimeoutExit != false {
      try visitor.visitSingularBoolField(value: self.aiStatusTimeoutExit, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 2)
    }
    if self.aiTypewriterEffectSupport != false {
      try visitor.visitSingularBoolField(value: self.aiTypewriterEffectSupport, fieldNumber: 3)
    }
    if self.aiApplicationSkillSupport != false {
      try visitor.visitSingularBoolField(value: self.aiApplicationSkillSupport, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_voice_assistant_function_table, rhs: protocol_voice_assistant_function_table) -> Bool {
    if lhs.aiStatusTimeoutExit != rhs.aiStatusTimeoutExit {return false}
    if lhs.version != rhs.version {return false}
    if lhs.aiTypewriterEffectSupport != rhs.aiTypewriterEffectSupport {return false}
    if lhs.aiApplicationSkillSupport != rhs.aiApplicationSkillSupport {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_voice_assistant_dial_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_voice_assistant_dial_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tran_type"),
    2: .standard(proto: "dial_type"),
    3: .standard(proto: "extra_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.tranType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.dialType) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.extraInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tranType != .watchTran {
      try visitor.visitSingularEnumField(value: self.tranType, fieldNumber: 1)
    }
    if self.dialType != .aiDialNull {
      try visitor.visitSingularEnumField(value: self.dialType, fieldNumber: 2)
    }
    if !self.extraInfo.isEmpty {
      try visitor.visitSingularBytesField(value: self.extraInfo, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_voice_assistant_dial_operate, rhs: protocol_voice_assistant_dial_operate) -> Bool {
    if lhs.tranType != rhs.tranType {return false}
    if lhs.dialType != rhs.dialType {return false}
    if lhs.extraInfo != rhs.extraInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_voice_assistant_string_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_voice_assistant_string_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tran_type"),
    2: .standard(proto: "string_type"),
    3: .standard(proto: "extra_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.tranType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.stringType) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.extraInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tranType != .watchTran {
      try visitor.visitSingularEnumField(value: self.tranType, fieldNumber: 1)
    }
    if self.stringType != .aiStringNull {
      try visitor.visitSingularEnumField(value: self.stringType, fieldNumber: 2)
    }
    if !self.extraInfo.isEmpty {
      try visitor.visitSingularBytesField(value: self.extraInfo, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_voice_assistant_string_operate, rhs: protocol_voice_assistant_string_operate) -> Bool {
    if lhs.tranType != rhs.tranType {return false}
    if lhs.stringType != rhs.stringType {return false}
    if lhs.extraInfo != rhs.extraInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_translation_assistant_config_info_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_translation_assistant_config_info_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tran_type"),
    2: .standard(proto: "current_language"),
    3: .standard(proto: "target_language"),
    4: .same(proto: "speed"),
    5: .standard(proto: "auto_pronounce"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.tranType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.currentLanguage) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.targetLanguage) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.speed) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.autoPronounce) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tranType != .watchTran {
      try visitor.visitSingularEnumField(value: self.tranType, fieldNumber: 1)
    }
    if self.currentLanguage != .langInvalid {
      try visitor.visitSingularEnumField(value: self.currentLanguage, fieldNumber: 2)
    }
    if self.targetLanguage != .langInvalid {
      try visitor.visitSingularEnumField(value: self.targetLanguage, fieldNumber: 3)
    }
    if self.speed != .aiTranslateSpeedUnknown {
      try visitor.visitSingularEnumField(value: self.speed, fieldNumber: 4)
    }
    if self.autoPronounce != false {
      try visitor.visitSingularBoolField(value: self.autoPronounce, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_translation_assistant_config_info_operate, rhs: protocol_translation_assistant_config_info_operate) -> Bool {
    if lhs.tranType != rhs.tranType {return false}
    if lhs.currentLanguage != rhs.currentLanguage {return false}
    if lhs.targetLanguage != rhs.targetLanguage {return false}
    if lhs.speed != rhs.speed {return false}
    if lhs.autoPronounce != rhs.autoPronounce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_translation_assistant_result_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_translation_assistant_result_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "echo_index"),
    3: .standard(proto: "echo_content"),
    4: .standard(proto: "end_recognition"),
    5: .standard(proto: "current_language"),
    6: .standard(proto: "answer_index"),
    7: .standard(proto: "answer_content"),
    8: .standard(proto: "answer_end_recognition"),
    9: .standard(proto: "target_language"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.echoIndex) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.echoContent) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.endRecognition) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.currentLanguage) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.answerIndex) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.answerContent) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.answerEndRecognition) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.targetLanguage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.echoIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.echoIndex, fieldNumber: 2)
    }
    if !self.echoContent.isEmpty {
      try visitor.visitSingularBytesField(value: self.echoContent, fieldNumber: 3)
    }
    if self.endRecognition != false {
      try visitor.visitSingularBoolField(value: self.endRecognition, fieldNumber: 4)
    }
    if self.currentLanguage != .langInvalid {
      try visitor.visitSingularEnumField(value: self.currentLanguage, fieldNumber: 5)
    }
    if self.answerIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.answerIndex, fieldNumber: 6)
    }
    if !self.answerContent.isEmpty {
      try visitor.visitSingularBytesField(value: self.answerContent, fieldNumber: 7)
    }
    if self.answerEndRecognition != false {
      try visitor.visitSingularBoolField(value: self.answerEndRecognition, fieldNumber: 8)
    }
    if self.targetLanguage != .langInvalid {
      try visitor.visitSingularEnumField(value: self.targetLanguage, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_translation_assistant_result_operate, rhs: protocol_translation_assistant_result_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.echoIndex != rhs.echoIndex {return false}
    if lhs.echoContent != rhs.echoContent {return false}
    if lhs.endRecognition != rhs.endRecognition {return false}
    if lhs.currentLanguage != rhs.currentLanguage {return false}
    if lhs.answerIndex != rhs.answerIndex {return false}
    if lhs.answerContent != rhs.answerContent {return false}
    if lhs.answerEndRecognition != rhs.answerEndRecognition {return false}
    if lhs.targetLanguage != rhs.targetLanguage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_translation_assistant_manual_send_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_translation_assistant_manual_send_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tran_type"),
    2: .standard(proto: "target_language"),
    3: .standard(proto: "extra_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.tranType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.targetLanguage) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.extraInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tranType != .watchTran {
      try visitor.visitSingularEnumField(value: self.tranType, fieldNumber: 1)
    }
    if self.targetLanguage != .langInvalid {
      try visitor.visitSingularEnumField(value: self.targetLanguage, fieldNumber: 2)
    }
    if !self.extraInfo.isEmpty {
      try visitor.visitSingularBytesField(value: self.extraInfo, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_translation_assistant_manual_send_operate, rhs: protocol_translation_assistant_manual_send_operate) -> Bool {
    if lhs.tranType != rhs.tranType {return false}
    if lhs.targetLanguage != rhs.targetLanguage {return false}
    if lhs.extraInfo != rhs.extraInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_ai_feature_config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_ai_feature_config"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_code"),
    2: .standard(proto: "start_time"),
    3: .standard(proto: "end_time"),
    4: .standard(proto: "is_subscribed"),
    5: .standard(proto: "is_subscription_supported"),
    6: .standard(proto: "daily_call_limit"),
    7: .standard(proto: "total_allowed_limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.userCode) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.startTime) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.endTime) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isSubscribed) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isSubscriptionSupported) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.dailyCallLimit) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.totalAllowedLimit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userCode.isEmpty {
      try visitor.visitSingularBytesField(value: self.userCode, fieldNumber: 1)
    }
    if self.startTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.startTime, fieldNumber: 2)
    }
    if self.endTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.endTime, fieldNumber: 3)
    }
    if self.isSubscribed != false {
      try visitor.visitSingularBoolField(value: self.isSubscribed, fieldNumber: 4)
    }
    if self.isSubscriptionSupported != false {
      try visitor.visitSingularBoolField(value: self.isSubscriptionSupported, fieldNumber: 5)
    }
    if self.dailyCallLimit != 0 {
      try visitor.visitSingularUInt32Field(value: self.dailyCallLimit, fieldNumber: 6)
    }
    if self.totalAllowedLimit != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalAllowedLimit, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_ai_feature_config, rhs: protocol_ai_feature_config) -> Bool {
    if lhs.userCode != rhs.userCode {return false}
    if lhs.startTime != rhs.startTime {return false}
    if lhs.endTime != rhs.endTime {return false}
    if lhs.isSubscribed != rhs.isSubscribed {return false}
    if lhs.isSubscriptionSupported != rhs.isSubscriptionSupported {return false}
    if lhs.dailyCallLimit != rhs.dailyCallLimit {return false}
    if lhs.totalAllowedLimit != rhs.totalAllowedLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_ai_feature_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_ai_feature_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .same(proto: "config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_ai_feature_operate, rhs: protocol_ai_feature_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs._config != rhs._config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_ai_feature_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_ai_feature_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .same(proto: "config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_ai_feature_reply, rhs: protocol_ai_feature_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs._config != rhs._config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ai_feature_local_status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ai_feature_local_status"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "system_time"),
    2: .standard(proto: "daily_count"),
    3: .standard(proto: "total_count"),
    4: .standard(proto: "daily_call_limit"),
    5: .standard(proto: "total_allowed_limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.systemTime) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.dailyCount) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.totalCount) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.dailyCallLimit) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.totalAllowedLimit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.systemTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.systemTime, fieldNumber: 1)
    }
    if self.dailyCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.dailyCount, fieldNumber: 2)
    }
    if self.totalCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalCount, fieldNumber: 3)
    }
    if self.dailyCallLimit != 0 {
      try visitor.visitSingularUInt32Field(value: self.dailyCallLimit, fieldNumber: 4)
    }
    if self.totalAllowedLimit != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalAllowedLimit, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ai_feature_local_status, rhs: ai_feature_local_status) -> Bool {
    if lhs.systemTime != rhs.systemTime {return false}
    if lhs.dailyCount != rhs.dailyCount {return false}
    if lhs.totalCount != rhs.totalCount {return false}
    if lhs.dailyCallLimit != rhs.dailyCallLimit {return false}
    if lhs.totalAllowedLimit != rhs.totalAllowedLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_ai_feature_notify_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_ai_feature_notify_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tran_type"),
    2: .same(proto: "type"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.tranType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.tranType != .watchTran {
      try visitor.visitSingularEnumField(value: self.tranType, fieldNumber: 1)
    }
    if self.type != .updataConfig {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_ai_feature_notify_operate, rhs: protocol_ai_feature_notify_operate) -> Bool {
    if lhs.tranType != rhs.tranType {return false}
    if lhs.type != rhs.type {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
