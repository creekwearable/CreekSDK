// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: alexa.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct protocol_alexa_tran_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tranType: tran_direction_type = .watchTran

  ///alexa 传输操作
  public var operate: alexa_operate_type = .alexaOperateNull

  ///0 正常 非0失败
  public var errCode: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_alexa_status_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 传输类型 0：无效操作 1：手表发起 2：app发起
  public var tranType: tran_direction_type = .watchTran

  ///通知类型
  public var noticeType: alexa_noitce_type = .alexaNoticeNull

  ///状态类型
  public var statusType: alexa_status_type = .alexaStatusNull

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_alexa_result_operate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///是否问句
  public var isQuestion: Bool = false

  ///max:1000 结果内容
  public var content: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

////闹钟
public struct alexa_alarm_item: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///2bytes
  public var year: UInt32 = 0

  ///1bytes
  public var month: UInt32 = 0

  ///1bytes
  public var day: UInt32 = 0

  ///1bytes
  public var hour: UInt32 = 0

  ///1bytes
  public var minute: UInt32 = 0

  ///1bytes 开关
  public var switchFlag: Bool = false

  ///7bytes 重复 周一~周七
  public var `repeat`: [Bool] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_alexa_alarm_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///max：5 闹钟列表
  public var alarmItem: [alexa_alarm_item] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_alexa_alarm_inquire_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///1bytes 功能表
  public var funcTable: UInt32 = 0

  ///1bytes 闹钟支持最大数量
  public var alarmSupportMax: UInt32 = 0

  ///max：5 闹钟列表
  public var alarmItem: [alexa_alarm_item] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct alexa_reminder_item: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///2bytes
  public var year: UInt32 = 0

  ///1bytes
  public var month: UInt32 = 0

  ///1bytes
  public var day: UInt32 = 0

  ///1bytes
  public var hour: UInt32 = 0

  ///1bytes
  public var minute: UInt32 = 0

  ///max:50 内容
  public var content: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_alexa_reminder_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///max：5 提醒列表
  public var reminderItem: [alexa_reminder_item] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_alexa_reminder_inquire_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///1bytes 功能表
  public var funcTable: UInt32 = 0

  ///1bytes 提醒支持最大数量
  public var reminderSupportMax: UInt32 = 0

  ///max：5 提醒列表
  public var reminderItem: [alexa_reminder_item] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct alexa_timer_item: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var index: UInt32 = 0

  public var timerSec: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_alexa_timer_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///定时器操作
  public var timerOperate: alexa_timer_operate = .alexaTimerInsert

  ///定时器编号
  public var index: UInt32 = 0

  ///定时时间 单位秒
  public var timerSec: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_alexa_timer_inquire_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///1bytes 功能表
  public var funcTable: UInt32 = 0

  ///1bytes 提醒支持最大数量
  public var timerSupportMax: UInt32 = 0

  ///定时器列表
  public var items: [alexa_timer_item] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct alexa_weather_future_item: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 天气类型
  public var weatherType: Data = Data()

  ///1bytes 最大温度
  public var maxTemp: Int32 = 0

  ///1bytes 最小温度
  public var minTemp: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct alexa_weather_detail_data_item: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///最新同步
  public var year: UInt32 = 0

  /// 月份
  public var month: UInt32 = 0

  public var day: UInt32 = 0

  ///时
  public var hour: UInt32 = 0

  ///分
  public var min: UInt32 = 0

  ///1bytes 星期  0x00无效 0x01~0x07:星期一~星期日
  public var week: UInt32 = 0

  /// 天气类型
  public var weatherType: Data = Data()

  ///1bytes 当前的温度
  public var curTemp: Int32 = 0

  ///1bytes 最大温度
  public var curMaxTemp: Int32 = 0

  ///1bytes 最小温度
  public var curMinTemp: Int32 = 0

  ///max:60 城市名称
  public var cityName: Data = Data()

  ///最近七天天气
  public var futureItems: [alexa_weather_future_item] = []

  ///温度单位，0：摄氏度，1：华氏度
  public var tempUnit: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_alexa_weather_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  public var detailDataItem: alexa_weather_detail_data_item {
    get {return _detailDataItem ?? alexa_weather_detail_data_item()}
    set {_detailDataItem = newValue}
  }
  /// Returns true if `detailDataItem` has been explicitly set.
  public var hasDetailDataItem: Bool {return self._detailDataItem != nil}
  /// Clears the value of `detailDataItem`. Subsequent reads from it will return its default value.
  public mutating func clearDetailDataItem() {self._detailDataItem = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _detailDataItem: alexa_weather_detail_data_item? = nil
}

public struct protocol_alexa_weather_inquire_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///1bytes 功能表
  public var funcTable: UInt32 = 0

  ///1bytes 天气详情支持最大数量
  public var weatherSupportMax: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

////通知
public struct protocol_alexa_notify_status_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///通知状态
  public var notifyStatus: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_alexa_notify_status_inquire_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///通知状态
  public var notifyStatus: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///alexa开关
public struct protocol_alexa_config_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///该地区是否支持alexa
  public var alexaSupport: Bool = false

  ///alexa设置开关
  public var alexaSwitch: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_alexa_config_inquire_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///alexa设置开关
  public var alexaSwitch: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_voice_assistant_tran_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tranType: tran_direction_type = .watchTran

  /// 传输操作
  public var operate: voice_assistant_operate_type = .aiOperateNull

  ///0 正常 非0失败
  public var errCode: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_voice_assistant_status_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 传输类型 0：无效操作 1：手表发起 2：app发起
  public var tranType: tran_direction_type = .watchTran

  ///通知类型
  public var noticeType: voice_assistant_noitce_type = .aiNoticeNull

  ///状态类型
  public var statusType: voice_assistant_status_type = .aiStatusNull

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_voice_assistant_result_operate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///是否问句
  public var isQuestion: Bool = false

  ///回显索引，新语句从1开始
  public var echoIndex: UInt32 = 0

  ///max:1000 回显内容，支持拼接
  public var echoContent: Data = Data()

  ///结果索引，新语句从1开始
  public var answerIndex: UInt32 = 0

  ///max:1000 结果内容，支持拼接
  public var answerContent: Data = Data()

  ///自己名字
  public var ownName: Data = Data()

  ///对话名字
  public var talkName: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension protocol_alexa_tran_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_tran_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tran_type"),
    2: .same(proto: "operate"),
    3: .standard(proto: "err_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.tranType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.errCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tranType != .watchTran {
      try visitor.visitSingularEnumField(value: self.tranType, fieldNumber: 1)
    }
    if self.operate != .alexaOperateNull {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 2)
    }
    if self.errCode != 0 {
      try visitor.visitSingularUInt32Field(value: self.errCode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_tran_operate, rhs: protocol_alexa_tran_operate) -> Bool {
    if lhs.tranType != rhs.tranType {return false}
    if lhs.operate != rhs.operate {return false}
    if lhs.errCode != rhs.errCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_status_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_status_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tran_type"),
    2: .standard(proto: "notice_type"),
    3: .standard(proto: "status_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.tranType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.noticeType) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.statusType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tranType != .watchTran {
      try visitor.visitSingularEnumField(value: self.tranType, fieldNumber: 1)
    }
    if self.noticeType != .alexaNoticeNull {
      try visitor.visitSingularEnumField(value: self.noticeType, fieldNumber: 2)
    }
    if self.statusType != .alexaStatusNull {
      try visitor.visitSingularEnumField(value: self.statusType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_status_operate, rhs: protocol_alexa_status_operate) -> Bool {
    if lhs.tranType != rhs.tranType {return false}
    if lhs.noticeType != rhs.noticeType {return false}
    if lhs.statusType != rhs.statusType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_result_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_result_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "is_question"),
    3: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isQuestion) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.isQuestion != false {
      try visitor.visitSingularBoolField(value: self.isQuestion, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_result_operate, rhs: protocol_alexa_result_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.isQuestion != rhs.isQuestion {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension alexa_alarm_item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "alexa_alarm_item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "year"),
    2: .same(proto: "month"),
    3: .same(proto: "day"),
    4: .same(proto: "hour"),
    5: .same(proto: "minute"),
    6: .standard(proto: "switch_flag"),
    7: .same(proto: "repeat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.year) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.month) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.day) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.hour) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.minute) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.switchFlag) }()
      case 7: try { try decoder.decodeRepeatedBoolField(value: &self.`repeat`) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.year != 0 {
      try visitor.visitSingularUInt32Field(value: self.year, fieldNumber: 1)
    }
    if self.month != 0 {
      try visitor.visitSingularUInt32Field(value: self.month, fieldNumber: 2)
    }
    if self.day != 0 {
      try visitor.visitSingularUInt32Field(value: self.day, fieldNumber: 3)
    }
    if self.hour != 0 {
      try visitor.visitSingularUInt32Field(value: self.hour, fieldNumber: 4)
    }
    if self.minute != 0 {
      try visitor.visitSingularUInt32Field(value: self.minute, fieldNumber: 5)
    }
    if self.switchFlag != false {
      try visitor.visitSingularBoolField(value: self.switchFlag, fieldNumber: 6)
    }
    if !self.`repeat`.isEmpty {
      try visitor.visitPackedBoolField(value: self.`repeat`, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: alexa_alarm_item, rhs: alexa_alarm_item) -> Bool {
    if lhs.year != rhs.year {return false}
    if lhs.month != rhs.month {return false}
    if lhs.day != rhs.day {return false}
    if lhs.hour != rhs.hour {return false}
    if lhs.minute != rhs.minute {return false}
    if lhs.switchFlag != rhs.switchFlag {return false}
    if lhs.`repeat` != rhs.`repeat` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_alarm_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_alarm_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "alarm_item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.alarmItem) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if !self.alarmItem.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.alarmItem, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_alarm_operate, rhs: protocol_alexa_alarm_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.alarmItem != rhs.alarmItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_alarm_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_alarm_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "func_table"),
    3: .standard(proto: "alarm_support_max"),
    4: .standard(proto: "alarm_item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.funcTable) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.alarmSupportMax) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.alarmItem) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.funcTable != 0 {
      try visitor.visitSingularUInt32Field(value: self.funcTable, fieldNumber: 2)
    }
    if self.alarmSupportMax != 0 {
      try visitor.visitSingularUInt32Field(value: self.alarmSupportMax, fieldNumber: 3)
    }
    if !self.alarmItem.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.alarmItem, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_alarm_inquire_reply, rhs: protocol_alexa_alarm_inquire_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.funcTable != rhs.funcTable {return false}
    if lhs.alarmSupportMax != rhs.alarmSupportMax {return false}
    if lhs.alarmItem != rhs.alarmItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension alexa_reminder_item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "alexa_reminder_item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "year"),
    2: .same(proto: "month"),
    3: .same(proto: "day"),
    4: .same(proto: "hour"),
    5: .same(proto: "minute"),
    6: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.year) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.month) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.day) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.hour) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.minute) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.year != 0 {
      try visitor.visitSingularUInt32Field(value: self.year, fieldNumber: 1)
    }
    if self.month != 0 {
      try visitor.visitSingularUInt32Field(value: self.month, fieldNumber: 2)
    }
    if self.day != 0 {
      try visitor.visitSingularUInt32Field(value: self.day, fieldNumber: 3)
    }
    if self.hour != 0 {
      try visitor.visitSingularUInt32Field(value: self.hour, fieldNumber: 4)
    }
    if self.minute != 0 {
      try visitor.visitSingularUInt32Field(value: self.minute, fieldNumber: 5)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: alexa_reminder_item, rhs: alexa_reminder_item) -> Bool {
    if lhs.year != rhs.year {return false}
    if lhs.month != rhs.month {return false}
    if lhs.day != rhs.day {return false}
    if lhs.hour != rhs.hour {return false}
    if lhs.minute != rhs.minute {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_reminder_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_reminder_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "reminder_item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.reminderItem) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if !self.reminderItem.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reminderItem, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_reminder_operate, rhs: protocol_alexa_reminder_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.reminderItem != rhs.reminderItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_reminder_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_reminder_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "func_table"),
    3: .standard(proto: "reminder_support_max"),
    4: .standard(proto: "reminder_item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.funcTable) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.reminderSupportMax) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.reminderItem) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.funcTable != 0 {
      try visitor.visitSingularUInt32Field(value: self.funcTable, fieldNumber: 2)
    }
    if self.reminderSupportMax != 0 {
      try visitor.visitSingularUInt32Field(value: self.reminderSupportMax, fieldNumber: 3)
    }
    if !self.reminderItem.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reminderItem, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_reminder_inquire_reply, rhs: protocol_alexa_reminder_inquire_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.funcTable != rhs.funcTable {return false}
    if lhs.reminderSupportMax != rhs.reminderSupportMax {return false}
    if lhs.reminderItem != rhs.reminderItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension alexa_timer_item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "alexa_timer_item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .standard(proto: "timer_sec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.timerSec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    if self.timerSec != 0 {
      try visitor.visitSingularUInt32Field(value: self.timerSec, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: alexa_timer_item, rhs: alexa_timer_item) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.timerSec != rhs.timerSec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_timer_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_timer_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "timer_operate"),
    3: .same(proto: "index"),
    4: .standard(proto: "timer_sec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.timerOperate) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.timerSec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.timerOperate != .alexaTimerInsert {
      try visitor.visitSingularEnumField(value: self.timerOperate, fieldNumber: 2)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 3)
    }
    if self.timerSec != 0 {
      try visitor.visitSingularUInt32Field(value: self.timerSec, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_timer_operate, rhs: protocol_alexa_timer_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.timerOperate != rhs.timerOperate {return false}
    if lhs.index != rhs.index {return false}
    if lhs.timerSec != rhs.timerSec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_timer_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_timer_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "func_table"),
    3: .standard(proto: "timer_support_max"),
    4: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.funcTable) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.timerSupportMax) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.funcTable != 0 {
      try visitor.visitSingularUInt32Field(value: self.funcTable, fieldNumber: 2)
    }
    if self.timerSupportMax != 0 {
      try visitor.visitSingularUInt32Field(value: self.timerSupportMax, fieldNumber: 3)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_timer_inquire_reply, rhs: protocol_alexa_timer_inquire_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.funcTable != rhs.funcTable {return false}
    if lhs.timerSupportMax != rhs.timerSupportMax {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension alexa_weather_future_item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "alexa_weather_future_item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "weather_type"),
    2: .standard(proto: "max_temp"),
    3: .standard(proto: "min_temp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.weatherType) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxTemp) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.minTemp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.weatherType.isEmpty {
      try visitor.visitSingularBytesField(value: self.weatherType, fieldNumber: 1)
    }
    if self.maxTemp != 0 {
      try visitor.visitSingularInt32Field(value: self.maxTemp, fieldNumber: 2)
    }
    if self.minTemp != 0 {
      try visitor.visitSingularInt32Field(value: self.minTemp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: alexa_weather_future_item, rhs: alexa_weather_future_item) -> Bool {
    if lhs.weatherType != rhs.weatherType {return false}
    if lhs.maxTemp != rhs.maxTemp {return false}
    if lhs.minTemp != rhs.minTemp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension alexa_weather_detail_data_item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "alexa_weather_detail_data_item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "year"),
    2: .same(proto: "month"),
    3: .same(proto: "day"),
    4: .same(proto: "hour"),
    5: .same(proto: "min"),
    6: .same(proto: "week"),
    7: .standard(proto: "weather_type"),
    8: .standard(proto: "cur_temp"),
    9: .standard(proto: "cur_max_temp"),
    10: .standard(proto: "cur_min_temp"),
    11: .standard(proto: "city_name"),
    12: .standard(proto: "future_items"),
    13: .standard(proto: "temp_unit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.year) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.month) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.day) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.hour) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.min) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.week) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.weatherType) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.curTemp) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.curMaxTemp) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.curMinTemp) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self.cityName) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.futureItems) }()
      case 13: try { try decoder.decodeSingularUInt32Field(value: &self.tempUnit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.year != 0 {
      try visitor.visitSingularUInt32Field(value: self.year, fieldNumber: 1)
    }
    if self.month != 0 {
      try visitor.visitSingularUInt32Field(value: self.month, fieldNumber: 2)
    }
    if self.day != 0 {
      try visitor.visitSingularUInt32Field(value: self.day, fieldNumber: 3)
    }
    if self.hour != 0 {
      try visitor.visitSingularUInt32Field(value: self.hour, fieldNumber: 4)
    }
    if self.min != 0 {
      try visitor.visitSingularUInt32Field(value: self.min, fieldNumber: 5)
    }
    if self.week != 0 {
      try visitor.visitSingularUInt32Field(value: self.week, fieldNumber: 6)
    }
    if !self.weatherType.isEmpty {
      try visitor.visitSingularBytesField(value: self.weatherType, fieldNumber: 7)
    }
    if self.curTemp != 0 {
      try visitor.visitSingularInt32Field(value: self.curTemp, fieldNumber: 8)
    }
    if self.curMaxTemp != 0 {
      try visitor.visitSingularInt32Field(value: self.curMaxTemp, fieldNumber: 9)
    }
    if self.curMinTemp != 0 {
      try visitor.visitSingularInt32Field(value: self.curMinTemp, fieldNumber: 10)
    }
    if !self.cityName.isEmpty {
      try visitor.visitSingularBytesField(value: self.cityName, fieldNumber: 11)
    }
    if !self.futureItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.futureItems, fieldNumber: 12)
    }
    if self.tempUnit != 0 {
      try visitor.visitSingularUInt32Field(value: self.tempUnit, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: alexa_weather_detail_data_item, rhs: alexa_weather_detail_data_item) -> Bool {
    if lhs.year != rhs.year {return false}
    if lhs.month != rhs.month {return false}
    if lhs.day != rhs.day {return false}
    if lhs.hour != rhs.hour {return false}
    if lhs.min != rhs.min {return false}
    if lhs.week != rhs.week {return false}
    if lhs.weatherType != rhs.weatherType {return false}
    if lhs.curTemp != rhs.curTemp {return false}
    if lhs.curMaxTemp != rhs.curMaxTemp {return false}
    if lhs.curMinTemp != rhs.curMinTemp {return false}
    if lhs.cityName != rhs.cityName {return false}
    if lhs.futureItems != rhs.futureItems {return false}
    if lhs.tempUnit != rhs.tempUnit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_weather_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_weather_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "detail_data_item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._detailDataItem) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    try { if let v = self._detailDataItem {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_weather_operate, rhs: protocol_alexa_weather_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs._detailDataItem != rhs._detailDataItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_weather_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_weather_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "func_table"),
    3: .standard(proto: "weather_support_max"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.funcTable) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.weatherSupportMax) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.funcTable != 0 {
      try visitor.visitSingularUInt32Field(value: self.funcTable, fieldNumber: 2)
    }
    if self.weatherSupportMax != 0 {
      try visitor.visitSingularUInt32Field(value: self.weatherSupportMax, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_weather_inquire_reply, rhs: protocol_alexa_weather_inquire_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.funcTable != rhs.funcTable {return false}
    if lhs.weatherSupportMax != rhs.weatherSupportMax {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_notify_status_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_notify_status_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "notify_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.notifyStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.notifyStatus != false {
      try visitor.visitSingularBoolField(value: self.notifyStatus, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_notify_status_operate, rhs: protocol_alexa_notify_status_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.notifyStatus != rhs.notifyStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_notify_status_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_notify_status_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "notify_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.notifyStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.notifyStatus != false {
      try visitor.visitSingularBoolField(value: self.notifyStatus, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_notify_status_inquire_reply, rhs: protocol_alexa_notify_status_inquire_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.notifyStatus != rhs.notifyStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_config_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_config_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "alexa_support"),
    3: .standard(proto: "alexa_switch"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.alexaSupport) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.alexaSwitch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.alexaSupport != false {
      try visitor.visitSingularBoolField(value: self.alexaSupport, fieldNumber: 2)
    }
    if self.alexaSwitch != false {
      try visitor.visitSingularBoolField(value: self.alexaSwitch, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_config_operate, rhs: protocol_alexa_config_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.alexaSupport != rhs.alexaSupport {return false}
    if lhs.alexaSwitch != rhs.alexaSwitch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_alexa_config_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_alexa_config_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "alexa_switch"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.alexaSwitch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.alexaSwitch != false {
      try visitor.visitSingularBoolField(value: self.alexaSwitch, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_alexa_config_inquire_reply, rhs: protocol_alexa_config_inquire_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.alexaSwitch != rhs.alexaSwitch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_voice_assistant_tran_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_voice_assistant_tran_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tran_type"),
    2: .same(proto: "operate"),
    3: .standard(proto: "err_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.tranType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.errCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tranType != .watchTran {
      try visitor.visitSingularEnumField(value: self.tranType, fieldNumber: 1)
    }
    if self.operate != .aiOperateNull {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 2)
    }
    if self.errCode != 0 {
      try visitor.visitSingularUInt32Field(value: self.errCode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_voice_assistant_tran_operate, rhs: protocol_voice_assistant_tran_operate) -> Bool {
    if lhs.tranType != rhs.tranType {return false}
    if lhs.operate != rhs.operate {return false}
    if lhs.errCode != rhs.errCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_voice_assistant_status_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_voice_assistant_status_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tran_type"),
    2: .standard(proto: "notice_type"),
    3: .standard(proto: "status_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.tranType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.noticeType) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.statusType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tranType != .watchTran {
      try visitor.visitSingularEnumField(value: self.tranType, fieldNumber: 1)
    }
    if self.noticeType != .aiNoticeNull {
      try visitor.visitSingularEnumField(value: self.noticeType, fieldNumber: 2)
    }
    if self.statusType != .aiStatusNull {
      try visitor.visitSingularEnumField(value: self.statusType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_voice_assistant_status_operate, rhs: protocol_voice_assistant_status_operate) -> Bool {
    if lhs.tranType != rhs.tranType {return false}
    if lhs.noticeType != rhs.noticeType {return false}
    if lhs.statusType != rhs.statusType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_voice_assistant_result_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_voice_assistant_result_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "is_question"),
    3: .standard(proto: "echo_index"),
    4: .standard(proto: "echo_content"),
    5: .standard(proto: "answer_index"),
    6: .standard(proto: "answer_content"),
    7: .standard(proto: "own_name"),
    8: .standard(proto: "talk_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isQuestion) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.echoIndex) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.echoContent) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.answerIndex) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.answerContent) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.ownName) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.talkName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.isQuestion != false {
      try visitor.visitSingularBoolField(value: self.isQuestion, fieldNumber: 2)
    }
    if self.echoIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.echoIndex, fieldNumber: 3)
    }
    if !self.echoContent.isEmpty {
      try visitor.visitSingularBytesField(value: self.echoContent, fieldNumber: 4)
    }
    if self.answerIndex != 0 {
      try visitor.visitSingularUInt32Field(value: self.answerIndex, fieldNumber: 5)
    }
    if !self.answerContent.isEmpty {
      try visitor.visitSingularBytesField(value: self.answerContent, fieldNumber: 6)
    }
    if !self.ownName.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownName, fieldNumber: 7)
    }
    if !self.talkName.isEmpty {
      try visitor.visitSingularBytesField(value: self.talkName, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_voice_assistant_result_operate, rhs: protocol_voice_assistant_result_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.isQuestion != rhs.isQuestion {return false}
    if lhs.echoIndex != rhs.echoIndex {return false}
    if lhs.echoContent != rhs.echoContent {return false}
    if lhs.answerIndex != rhs.answerIndex {return false}
    if lhs.answerContent != rhs.answerContent {return false}
    if lhs.ownName != rhs.ownName {return false}
    if lhs.talkName != rhs.talkName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
