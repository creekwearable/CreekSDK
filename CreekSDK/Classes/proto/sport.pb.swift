// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: sport.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///获取设备支持运动类型
public struct protocol_exercise_func_support_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///功能表
  public var funcTable: UInt32 = 0

  public var supportType: [sport_type] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///设备运动排列顺序 
public struct protocol_exercise_sport_mode_sort: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///1bytes 运动排序个数
  public var itemsLen: UInt32 = 0

  ///运动列表排序
  public var sportItems: [sport_type] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_exercise_sport_mode_sort_inquire_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///1bytes 固件运动列表最少显示个数
  public var minShowNum: UInt32 = 0

  ///1bytes 固件运动列表最大显示个数
  public var maxShowNum: UInt32 = 0

  ///1bytes 固件支持的运动总数
  public var allNum: UInt32 = 0

  ///1bytes 运动排序个数
  public var itemsLen: UInt32 = 0

  ///运动列表排序
  public var sportItems: [sport_type] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///运动中子项数据
public struct protocol_exercise_sporting_param_sort: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///1bytes 运动类型
  public var sportType: UInt32 = 0

  ///1bytes 运动中子项数据排序列表个数
  public var itemsLen: UInt32 = 0

  ///运动中子项数据排序列表
  public var items: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_exercise_sporting_param_sort_inquire_reply: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///1bytes 运动类型
  public var sportType: sport_type = .orun

  ///1bytes 运动中子项数据排序列表个数
  public var itemsLen: UInt32 = 0

  ///运动中子项数据排序列表
  public var items: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///运动自识别
public struct protocol_exercise_intelligent_recognition: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///1bytes 运动自动识别开关 true 开启 = 1;false 关闭
  public var sportRecognitionSwitch: Bool = false

  ///1bytes 运动自动暂停开关 true 开启 = 1;false 关闭
  public var sportAutoPauseSwitch: Bool = false

  ///1bytes 运动自动结束开关 true 开启 = 1;false 关闭
  public var sportAutoEndSwitch: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_exercise_intelligent_recognition_inquire_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///1bytes 运动自动识别开关 true 开启 = 1;false 关闭
  public var sportRecognitionSwitch: Bool = false

  ///1bytes 运动自动暂停开关 true 开启 = 1;false 关闭
  public var sportAutoPauseSwitch: Bool = false

  ///1bytes 运动自动结束开关 true 开启 = 1;false 关闭
  public var sportAutoEndSwitch: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///心率区间
public struct protocol_exercise_heart_rate_zone: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///1bytes 心率区间1
  public var zone1: UInt32 = 0

  ///1bytes 心率区间2
  public var zone2: UInt32 = 0

  ///1bytes 心率区间3
  public var zone3: UInt32 = 0

  ///1bytes 心率区间4
  public var zone4: UInt32 = 0

  ///1bytes 心率区间5
  public var zone5: UInt32 = 0

  ///1bytes 心率区间6
  public var zone6: UInt32 = 0

  ///心率区间模式
  public var hrMode: heart_rate_zone_mode = .hrMaxMode

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_exercise_heart_rate_zone_inquire_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///查询返回的是储备心率区间
  public var zone1: UInt32 = 0

  ///1bytes 心率区间2
  public var zone2: UInt32 = 0

  ///1bytes 心率区间3
  public var zone3: UInt32 = 0

  ///1bytes 心率区间4
  public var zone4: UInt32 = 0

  ///1bytes 心率区间5
  public var zone5: UInt32 = 0

  ///1bytes 心率区间6
  public var zone6: UInt32 = 0

  ///心率区间模式
  public var hrMode: heart_rate_zone_mode = .hrMaxMode

  ///功能表
  public var funcTable: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_exercise_gps_info: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///gps信息请求或结束
  public var gpsOperate: gps_operate_type = .gpsInfoRequest

  ///1bytes 功能表
  public var funcTable: UInt32 = 0

  ///1bytes 运动类型
  public var sportType: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_exercise_gps_info_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///纬度 负数:S南纬  正数：N北纬 放大10000000倍
  public var rmcLatitude: Int32 = 0

  ///经度 负数:W西经  正数：E东经 放大10000000倍
  public var rmcLongitude: Int32 = 0

  ///1=未定位，2=2D定位，3=3D定位
  public var gsaLocationType: UInt32 = 0

  ///经度因子，放大100倍
  public var gsaPdop: UInt32 = 0

  ///gps定位权限开关是否打开
  public var gpsPermission: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///同步历史最大摄氧量
public struct protocol_vo2max_history: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var vo2Max: UInt32 = 0

  public var utcTime: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_exercise_vo2max_info: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///历史最大摄氧量 max:10组数据
  public var vo2MaxHistory: [protocol_vo2max_history] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_exercise_sync_realtime_info: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tranType: tran_direction_type {
    get {return _storage._tranType}
    set {_uniqueStorage()._tranType = newValue}
  }

  ///运动类型
  public var sportType: sport_type {
    get {return _storage._sportType}
    set {_uniqueStorage()._sportType = newValue}
  }

  ///运动时长； 单位： s
  public var totalDurations: UInt32 {
    get {return _storage._totalDurations}
    set {_uniqueStorage()._totalDurations = newValue}
  }

  ///公里配速
  public var kmPace: UInt32 {
    get {return _storage._kmPace}
    set {_uniqueStorage()._kmPace = newValue}
  }

  ///平均公里配速
  public var avgKmPace: UInt32 {
    get {return _storage._avgKmPace}
    set {_uniqueStorage()._avgKmPace = newValue}
  }

  ///英里配速
  public var miPace: UInt32 {
    get {return _storage._miPace}
    set {_uniqueStorage()._miPace = newValue}
  }

  ///平均英里配速
  public var avgMiPace: UInt32 {
    get {return _storage._avgMiPace}
    set {_uniqueStorage()._avgMiPace = newValue}
  }

  ///公里速度
  public var kmSpeed: UInt32 {
    get {return _storage._kmSpeed}
    set {_uniqueStorage()._kmSpeed = newValue}
  }

  ///平均公里速度
  public var avgKmSpeed: UInt32 {
    get {return _storage._avgKmSpeed}
    set {_uniqueStorage()._avgKmSpeed = newValue}
  }

  ///英里速度
  public var miSpeed: UInt32 {
    get {return _storage._miSpeed}
    set {_uniqueStorage()._miSpeed = newValue}
  }

  ///平均英里速度
  public var avgMiSpeed: UInt32 {
    get {return _storage._avgMiSpeed}
    set {_uniqueStorage()._avgMiSpeed = newValue}
  }

  ///距离；单位： m
  public var totalDistance: UInt32 {
    get {return _storage._totalDistance}
    set {_uniqueStorage()._totalDistance = newValue}
  }

  ///纬度 负数:S南纬  正数：N北纬 放大1000000倍
  public var latitude: Int32 {
    get {return _storage._latitude}
    set {_uniqueStorage()._latitude = newValue}
  }

  ///经度 负数:W西经  正数：E东经 放大1000000倍
  public var longitude: Int32 {
    get {return _storage._longitude}
    set {_uniqueStorage()._longitude = newValue}
  }

  ///海拔数据
  public var elevation: Int32 {
    get {return _storage._elevation}
    set {_uniqueStorage()._elevation = newValue}
  }

  ///步幅
  public var stepStride: UInt32 {
    get {return _storage._stepStride}
    set {_uniqueStorage()._stepStride = newValue}
  }

  ///步频
  public var stepFrequency: UInt32 {
    get {return _storage._stepFrequency}
    set {_uniqueStorage()._stepFrequency = newValue}
  }

  ///累计爬升高度
  public var totalClimbHeight: UInt32 {
    get {return _storage._totalClimbHeight}
    set {_uniqueStorage()._totalClimbHeight = newValue}
  }

  ///心率值
  public var hrValue: UInt32 {
    get {return _storage._hrValue}
    set {_uniqueStorage()._hrValue = newValue}
  }

  ///最大心率值
  public var maxHrValue: UInt32 {
    get {return _storage._maxHrValue}
    set {_uniqueStorage()._maxHrValue = newValue}
  }

  ///最小心率值
  public var minHrValue: UInt32 {
    get {return _storage._minHrValue}
    set {_uniqueStorage()._minHrValue = newValue}
  }

  ///总卡路里
  public var totalCalories: UInt32 {
    get {return _storage._totalCalories}
    set {_uniqueStorage()._totalCalories = newValue}
  }

  ///分段次数
  public var lapCount: UInt32 {
    get {return _storage._lapCount}
    set {_uniqueStorage()._lapCount = newValue}
  }

  ///分段时长
  public var lapDuration: UInt32 {
    get {return _storage._lapDuration}
    set {_uniqueStorage()._lapDuration = newValue}
  }

  ///分段距离
  public var lapDistance: UInt32 {
    get {return _storage._lapDistance}
    set {_uniqueStorage()._lapDistance = newValue}
  }

  ///平均公里配速/速度，骑行类的用速度，其他是配速
  public var lapKmPaceSpeed: UInt32 {
    get {return _storage._lapKmPaceSpeed}
    set {_uniqueStorage()._lapKmPaceSpeed = newValue}
  }

  ///平均英里配速/速度 骑行类的用速度，其他是配速
  public var lapMiPaceSpeed: UInt32 {
    get {return _storage._lapMiPaceSpeed}
    set {_uniqueStorage()._lapMiPaceSpeed = newValue}
  }

  ///平均心率值
  public var avgHrValue: UInt32 {
    get {return _storage._avgHrValue}
    set {_uniqueStorage()._avgHrValue = newValue}
  }

  ///心率区间1累计秒数
  public var hrZone1Sec: UInt32 {
    get {return _storage._hrZone1Sec}
    set {_uniqueStorage()._hrZone1Sec = newValue}
  }

  ///心率区间2累计秒数
  public var hrZone2Sec: UInt32 {
    get {return _storage._hrZone2Sec}
    set {_uniqueStorage()._hrZone2Sec = newValue}
  }

  ///心率区间3累计秒数
  public var hrZone3Sec: UInt32 {
    get {return _storage._hrZone3Sec}
    set {_uniqueStorage()._hrZone3Sec = newValue}
  }

  ///心率区间4累计秒数
  public var hrZone4Sec: UInt32 {
    get {return _storage._hrZone4Sec}
    set {_uniqueStorage()._hrZone4Sec = newValue}
  }

  ///心率区间5累计秒数
  public var hrZone5Sec: UInt32 {
    get {return _storage._hrZone5Sec}
    set {_uniqueStorage()._hrZone5Sec = newValue}
  }

  ///海拔数据，爬升高度数据项是否支持
  public var elevationSupport: Bool {
    get {return _storage._elevationSupport}
    set {_uniqueStorage()._elevationSupport = newValue}
  }

  ///lap分段是否支持
  public var lapSupport: Bool {
    get {return _storage._lapSupport}
    set {_uniqueStorage()._lapSupport = newValue}
  }

  ///gps信号 0是无信号 1红 2橙，3绿
  public var gpsRssi: UInt32 {
    get {return _storage._gpsRssi}
    set {_uniqueStorage()._gpsRssi = newValue}
  }

  ///是否支持gps信号
  public var gpsSupport: Bool {
    get {return _storage._gpsSupport}
    set {_uniqueStorage()._gpsSupport = newValue}
  }

  ///步数显示是否支持
  public var stepSupport: Bool {
    get {return _storage._stepSupport}
    set {_uniqueStorage()._stepSupport = newValue}
  }

  ///步数
  public var totalStep: UInt32 {
    get {return _storage._totalStep}
    set {_uniqueStorage()._totalStep = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct protocol_exercise_control_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tranType: tran_direction_type = .watchTran

  ///运动类型
  public var sportType: sport_type = .orun

  ///运动控制类型
  public var controlType: exercise_control_type = .controlNull

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct course_list_item: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///课程唯一标识
  public var id: UInt32 = 0

  ///分支标识
  public var branchID: UInt32 = 0

  ///创建者ID
  public var creatorID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_exercise_course_list_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型
  public var operate: operate_course_list_type = .courseInvalid

  public var listItems: [course_list_item] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_exercise_course_list_inquire_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes操作类型
  public var operate: operate_course_list_type = .courseInvalid

  ///1bytes 功能表
  public var funcTable: UInt32 = 0

  ///max: 暂定50
  public var listItems: [course_list_item] = []

  ///运动课程目标支持列表
  public var targetSupport: [course_target_support_type] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_total_mileage_item: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///运动类型
  public var sportType: mileage_sport_type = .mileageNull

  ///时间范围
  public var timeType: mileage_time_type = .weekly

  ///目标类型
  public var targetType: mileage_target_type = .activity

  ///当前活动次数
  public var curActivityCount: UInt32 = 0

  ///当前距离
  public var curDistance: UInt32 = 0

  ///目标活动次数
  public var goalActivityCount: UInt32 = 0

  ///目标距离
  public var goalDistance: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_exercise_total_mileage_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  public var mileageItem: protocol_total_mileage_item {
    get {return _mileageItem ?? protocol_total_mileage_item()}
    set {_mileageItem = newValue}
  }
  /// Returns true if `mileageItem` has been explicitly set.
  public var hasMileageItem: Bool {return self._mileageItem != nil}
  /// Clears the value of `mileageItem`. Subsequent reads from it will return its default value.
  public mutating func clearMileageItem() {self._mileageItem = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _mileageItem: protocol_total_mileage_item? = nil
}

public struct protocol_exercise_total_mileage_inquire_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  ///1bytes 功能表
  public var funcTable: UInt32 = 0

  public var mileageItem: protocol_total_mileage_item {
    get {return _mileageItem ?? protocol_total_mileage_item()}
    set {_mileageItem = newValue}
  }
  /// Returns true if `mileageItem` has been explicitly set.
  public var hasMileageItem: Bool {return self._mileageItem != nil}
  /// Clears the value of `mileageItem`. Subsequent reads from it will return its default value.
  public mutating func clearMileageItem() {self._mileageItem = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _mileageItem: protocol_total_mileage_item? = nil
}

///设置动作指导数据子项数据
public struct action_list_item: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///唯一标识
  public var id: UInt32 = 0

  ///版本号
  public var version: UInt32 = 0

  ///类型
  public var type: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_exercise_action_list_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes 操作类型
  public var operate: operate_course_list_type = .courseInvalid

  public var listItems: [action_list_item] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_action_list_inquire_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes操作类型
  public var operate: operate_course_list_type = .courseInvalid

  ///1bytes 功能表
  public var funcTable: UInt32 = 0

  public var listItems: [action_list_item] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension protocol_exercise_func_support_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_exercise_func_support_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "func_table"),
    2: .standard(proto: "support_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.funcTable) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.supportType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.funcTable != 0 {
      try visitor.visitSingularUInt32Field(value: self.funcTable, fieldNumber: 1)
    }
    if !self.supportType.isEmpty {
      try visitor.visitPackedEnumField(value: self.supportType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_exercise_func_support_reply, rhs: protocol_exercise_func_support_reply) -> Bool {
    if lhs.funcTable != rhs.funcTable {return false}
    if lhs.supportType != rhs.supportType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_exercise_sport_mode_sort: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_exercise_sport_mode_sort"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "items_len"),
    3: .standard(proto: "sport_items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.itemsLen) }()
      case 3: try { try decoder.decodeRepeatedEnumField(value: &self.sportItems) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.itemsLen != 0 {
      try visitor.visitSingularUInt32Field(value: self.itemsLen, fieldNumber: 2)
    }
    if !self.sportItems.isEmpty {
      try visitor.visitPackedEnumField(value: self.sportItems, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_exercise_sport_mode_sort, rhs: protocol_exercise_sport_mode_sort) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.itemsLen != rhs.itemsLen {return false}
    if lhs.sportItems != rhs.sportItems {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_exercise_sport_mode_sort_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_exercise_sport_mode_sort_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "min_show_num"),
    3: .standard(proto: "max_show_num"),
    4: .standard(proto: "all_num"),
    5: .standard(proto: "items_len"),
    6: .standard(proto: "sport_items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.minShowNum) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.maxShowNum) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.allNum) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.itemsLen) }()
      case 6: try { try decoder.decodeRepeatedEnumField(value: &self.sportItems) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.minShowNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.minShowNum, fieldNumber: 2)
    }
    if self.maxShowNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxShowNum, fieldNumber: 3)
    }
    if self.allNum != 0 {
      try visitor.visitSingularUInt32Field(value: self.allNum, fieldNumber: 4)
    }
    if self.itemsLen != 0 {
      try visitor.visitSingularUInt32Field(value: self.itemsLen, fieldNumber: 5)
    }
    if !self.sportItems.isEmpty {
      try visitor.visitPackedEnumField(value: self.sportItems, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_exercise_sport_mode_sort_inquire_reply, rhs: protocol_exercise_sport_mode_sort_inquire_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.minShowNum != rhs.minShowNum {return false}
    if lhs.maxShowNum != rhs.maxShowNum {return false}
    if lhs.allNum != rhs.allNum {return false}
    if lhs.itemsLen != rhs.itemsLen {return false}
    if lhs.sportItems != rhs.sportItems {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_exercise_sporting_param_sort: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_exercise_sporting_param_sort"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "sport_type"),
    3: .standard(proto: "items_len"),
    4: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.sportType) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.itemsLen) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.sportType != 0 {
      try visitor.visitSingularUInt32Field(value: self.sportType, fieldNumber: 2)
    }
    if self.itemsLen != 0 {
      try visitor.visitSingularUInt32Field(value: self.itemsLen, fieldNumber: 3)
    }
    if !self.items.isEmpty {
      try visitor.visitSingularBytesField(value: self.items, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_exercise_sporting_param_sort, rhs: protocol_exercise_sporting_param_sort) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.sportType != rhs.sportType {return false}
    if lhs.itemsLen != rhs.itemsLen {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_exercise_sporting_param_sort_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_exercise_sporting_param_sort_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "sport_type"),
    3: .standard(proto: "items_len"),
    4: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.sportType) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.itemsLen) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.sportType != .orun {
      try visitor.visitSingularEnumField(value: self.sportType, fieldNumber: 2)
    }
    if self.itemsLen != 0 {
      try visitor.visitSingularUInt32Field(value: self.itemsLen, fieldNumber: 3)
    }
    if !self.items.isEmpty {
      try visitor.visitSingularBytesField(value: self.items, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_exercise_sporting_param_sort_inquire_reply, rhs: protocol_exercise_sporting_param_sort_inquire_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.sportType != rhs.sportType {return false}
    if lhs.itemsLen != rhs.itemsLen {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_exercise_intelligent_recognition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_exercise_intelligent_recognition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "sport_recognition_switch"),
    3: .standard(proto: "sport_auto_pause_switch"),
    4: .standard(proto: "sport_auto_end_switch"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.sportRecognitionSwitch) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.sportAutoPauseSwitch) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.sportAutoEndSwitch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.sportRecognitionSwitch != false {
      try visitor.visitSingularBoolField(value: self.sportRecognitionSwitch, fieldNumber: 2)
    }
    if self.sportAutoPauseSwitch != false {
      try visitor.visitSingularBoolField(value: self.sportAutoPauseSwitch, fieldNumber: 3)
    }
    if self.sportAutoEndSwitch != false {
      try visitor.visitSingularBoolField(value: self.sportAutoEndSwitch, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_exercise_intelligent_recognition, rhs: protocol_exercise_intelligent_recognition) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.sportRecognitionSwitch != rhs.sportRecognitionSwitch {return false}
    if lhs.sportAutoPauseSwitch != rhs.sportAutoPauseSwitch {return false}
    if lhs.sportAutoEndSwitch != rhs.sportAutoEndSwitch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_exercise_intelligent_recognition_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_exercise_intelligent_recognition_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "sport_recognition_switch"),
    3: .standard(proto: "sport_auto_pause_switch"),
    4: .standard(proto: "sport_auto_end_switch"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.sportRecognitionSwitch) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.sportAutoPauseSwitch) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.sportAutoEndSwitch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.sportRecognitionSwitch != false {
      try visitor.visitSingularBoolField(value: self.sportRecognitionSwitch, fieldNumber: 2)
    }
    if self.sportAutoPauseSwitch != false {
      try visitor.visitSingularBoolField(value: self.sportAutoPauseSwitch, fieldNumber: 3)
    }
    if self.sportAutoEndSwitch != false {
      try visitor.visitSingularBoolField(value: self.sportAutoEndSwitch, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_exercise_intelligent_recognition_inquire_reply, rhs: protocol_exercise_intelligent_recognition_inquire_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.sportRecognitionSwitch != rhs.sportRecognitionSwitch {return false}
    if lhs.sportAutoPauseSwitch != rhs.sportAutoPauseSwitch {return false}
    if lhs.sportAutoEndSwitch != rhs.sportAutoEndSwitch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_exercise_heart_rate_zone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_exercise_heart_rate_zone"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .same(proto: "zone1"),
    3: .same(proto: "zone2"),
    4: .same(proto: "zone3"),
    5: .same(proto: "zone4"),
    6: .same(proto: "zone5"),
    7: .same(proto: "zone6"),
    8: .standard(proto: "hr_mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.zone1) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.zone2) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.zone3) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.zone4) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.zone5) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.zone6) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.hrMode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.zone1 != 0 {
      try visitor.visitSingularUInt32Field(value: self.zone1, fieldNumber: 2)
    }
    if self.zone2 != 0 {
      try visitor.visitSingularUInt32Field(value: self.zone2, fieldNumber: 3)
    }
    if self.zone3 != 0 {
      try visitor.visitSingularUInt32Field(value: self.zone3, fieldNumber: 4)
    }
    if self.zone4 != 0 {
      try visitor.visitSingularUInt32Field(value: self.zone4, fieldNumber: 5)
    }
    if self.zone5 != 0 {
      try visitor.visitSingularUInt32Field(value: self.zone5, fieldNumber: 6)
    }
    if self.zone6 != 0 {
      try visitor.visitSingularUInt32Field(value: self.zone6, fieldNumber: 7)
    }
    if self.hrMode != .hrMaxMode {
      try visitor.visitSingularEnumField(value: self.hrMode, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_exercise_heart_rate_zone, rhs: protocol_exercise_heart_rate_zone) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.zone1 != rhs.zone1 {return false}
    if lhs.zone2 != rhs.zone2 {return false}
    if lhs.zone3 != rhs.zone3 {return false}
    if lhs.zone4 != rhs.zone4 {return false}
    if lhs.zone5 != rhs.zone5 {return false}
    if lhs.zone6 != rhs.zone6 {return false}
    if lhs.hrMode != rhs.hrMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_exercise_heart_rate_zone_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_exercise_heart_rate_zone_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .same(proto: "zone1"),
    3: .same(proto: "zone2"),
    4: .same(proto: "zone3"),
    5: .same(proto: "zone4"),
    6: .same(proto: "zone5"),
    7: .same(proto: "zone6"),
    8: .standard(proto: "hr_mode"),
    9: .standard(proto: "func_table"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.zone1) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.zone2) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.zone3) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.zone4) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.zone5) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.zone6) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.hrMode) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.funcTable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.zone1 != 0 {
      try visitor.visitSingularUInt32Field(value: self.zone1, fieldNumber: 2)
    }
    if self.zone2 != 0 {
      try visitor.visitSingularUInt32Field(value: self.zone2, fieldNumber: 3)
    }
    if self.zone3 != 0 {
      try visitor.visitSingularUInt32Field(value: self.zone3, fieldNumber: 4)
    }
    if self.zone4 != 0 {
      try visitor.visitSingularUInt32Field(value: self.zone4, fieldNumber: 5)
    }
    if self.zone5 != 0 {
      try visitor.visitSingularUInt32Field(value: self.zone5, fieldNumber: 6)
    }
    if self.zone6 != 0 {
      try visitor.visitSingularUInt32Field(value: self.zone6, fieldNumber: 7)
    }
    if self.hrMode != .hrMaxMode {
      try visitor.visitSingularEnumField(value: self.hrMode, fieldNumber: 8)
    }
    if self.funcTable != 0 {
      try visitor.visitSingularUInt32Field(value: self.funcTable, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_exercise_heart_rate_zone_inquire_reply, rhs: protocol_exercise_heart_rate_zone_inquire_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.zone1 != rhs.zone1 {return false}
    if lhs.zone2 != rhs.zone2 {return false}
    if lhs.zone3 != rhs.zone3 {return false}
    if lhs.zone4 != rhs.zone4 {return false}
    if lhs.zone5 != rhs.zone5 {return false}
    if lhs.zone6 != rhs.zone6 {return false}
    if lhs.hrMode != rhs.hrMode {return false}
    if lhs.funcTable != rhs.funcTable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_exercise_gps_info: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_exercise_gps_info"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "gps_operate"),
    3: .standard(proto: "func_table"),
    4: .standard(proto: "sport_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.gpsOperate) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.funcTable) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.sportType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.gpsOperate != .gpsInfoRequest {
      try visitor.visitSingularEnumField(value: self.gpsOperate, fieldNumber: 2)
    }
    if self.funcTable != 0 {
      try visitor.visitSingularUInt32Field(value: self.funcTable, fieldNumber: 3)
    }
    if self.sportType != 0 {
      try visitor.visitSingularUInt32Field(value: self.sportType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_exercise_gps_info, rhs: protocol_exercise_gps_info) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.gpsOperate != rhs.gpsOperate {return false}
    if lhs.funcTable != rhs.funcTable {return false}
    if lhs.sportType != rhs.sportType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_exercise_gps_info_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_exercise_gps_info_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "rmc_latitude"),
    3: .standard(proto: "rmc_longitude"),
    4: .standard(proto: "gsa_location_type"),
    5: .standard(proto: "gsa_pdop"),
    6: .standard(proto: "gps_permission"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.rmcLatitude) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.rmcLongitude) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.gsaLocationType) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.gsaPdop) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.gpsPermission) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.rmcLatitude != 0 {
      try visitor.visitSingularInt32Field(value: self.rmcLatitude, fieldNumber: 2)
    }
    if self.rmcLongitude != 0 {
      try visitor.visitSingularInt32Field(value: self.rmcLongitude, fieldNumber: 3)
    }
    if self.gsaLocationType != 0 {
      try visitor.visitSingularUInt32Field(value: self.gsaLocationType, fieldNumber: 4)
    }
    if self.gsaPdop != 0 {
      try visitor.visitSingularUInt32Field(value: self.gsaPdop, fieldNumber: 5)
    }
    if self.gpsPermission != false {
      try visitor.visitSingularBoolField(value: self.gpsPermission, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_exercise_gps_info_reply, rhs: protocol_exercise_gps_info_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.rmcLatitude != rhs.rmcLatitude {return false}
    if lhs.rmcLongitude != rhs.rmcLongitude {return false}
    if lhs.gsaLocationType != rhs.gsaLocationType {return false}
    if lhs.gsaPdop != rhs.gsaPdop {return false}
    if lhs.gpsPermission != rhs.gpsPermission {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_vo2max_history: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_vo2max_history"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vo2max"),
    2: .standard(proto: "utc_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.vo2Max) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.utcTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.vo2Max != 0 {
      try visitor.visitSingularUInt32Field(value: self.vo2Max, fieldNumber: 1)
    }
    if self.utcTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.utcTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_vo2max_history, rhs: protocol_vo2max_history) -> Bool {
    if lhs.vo2Max != rhs.vo2Max {return false}
    if lhs.utcTime != rhs.utcTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_exercise_vo2max_info: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_exercise_vo2max_info"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "vo2max_history"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.vo2MaxHistory) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if !self.vo2MaxHistory.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.vo2MaxHistory, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_exercise_vo2max_info, rhs: protocol_exercise_vo2max_info) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.vo2MaxHistory != rhs.vo2MaxHistory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_exercise_sync_realtime_info: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_exercise_sync_realtime_info"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tran_type"),
    2: .standard(proto: "sport_type"),
    3: .standard(proto: "total_durations"),
    4: .standard(proto: "km_pace"),
    5: .standard(proto: "avg_km_pace"),
    6: .standard(proto: "mi_pace"),
    7: .standard(proto: "avg_mi_pace"),
    8: .standard(proto: "km_speed"),
    9: .standard(proto: "avg_km_speed"),
    10: .standard(proto: "mi_speed"),
    11: .standard(proto: "avg_mi_speed"),
    12: .standard(proto: "total_distance"),
    13: .same(proto: "latitude"),
    14: .same(proto: "longitude"),
    15: .same(proto: "elevation"),
    16: .standard(proto: "step_stride"),
    17: .standard(proto: "step_frequency"),
    18: .standard(proto: "total_climb_height"),
    19: .standard(proto: "hr_value"),
    20: .standard(proto: "max_hr_value"),
    21: .standard(proto: "min_hr_value"),
    22: .standard(proto: "total_calories"),
    23: .standard(proto: "lap_count"),
    24: .standard(proto: "lap_duration"),
    25: .standard(proto: "lap_distance"),
    26: .standard(proto: "lap_km_pace_speed"),
    27: .standard(proto: "lap_mi_pace_speed"),
    28: .standard(proto: "avg_hr_value"),
    29: .standard(proto: "hr_zone1_sec"),
    30: .standard(proto: "hr_zone2_sec"),
    31: .standard(proto: "hr_zone3_sec"),
    32: .standard(proto: "hr_zone4_sec"),
    33: .standard(proto: "hr_zone5_sec"),
    34: .standard(proto: "elevation_support"),
    35: .standard(proto: "lap_support"),
    36: .standard(proto: "gps_rssi"),
    37: .standard(proto: "gps_support"),
    38: .standard(proto: "step_support"),
    39: .standard(proto: "total_step"),
  ]

  fileprivate class _StorageClass {
    var _tranType: tran_direction_type = .watchTran
    var _sportType: sport_type = .orun
    var _totalDurations: UInt32 = 0
    var _kmPace: UInt32 = 0
    var _avgKmPace: UInt32 = 0
    var _miPace: UInt32 = 0
    var _avgMiPace: UInt32 = 0
    var _kmSpeed: UInt32 = 0
    var _avgKmSpeed: UInt32 = 0
    var _miSpeed: UInt32 = 0
    var _avgMiSpeed: UInt32 = 0
    var _totalDistance: UInt32 = 0
    var _latitude: Int32 = 0
    var _longitude: Int32 = 0
    var _elevation: Int32 = 0
    var _stepStride: UInt32 = 0
    var _stepFrequency: UInt32 = 0
    var _totalClimbHeight: UInt32 = 0
    var _hrValue: UInt32 = 0
    var _maxHrValue: UInt32 = 0
    var _minHrValue: UInt32 = 0
    var _totalCalories: UInt32 = 0
    var _lapCount: UInt32 = 0
    var _lapDuration: UInt32 = 0
    var _lapDistance: UInt32 = 0
    var _lapKmPaceSpeed: UInt32 = 0
    var _lapMiPaceSpeed: UInt32 = 0
    var _avgHrValue: UInt32 = 0
    var _hrZone1Sec: UInt32 = 0
    var _hrZone2Sec: UInt32 = 0
    var _hrZone3Sec: UInt32 = 0
    var _hrZone4Sec: UInt32 = 0
    var _hrZone5Sec: UInt32 = 0
    var _elevationSupport: Bool = false
    var _lapSupport: Bool = false
    var _gpsRssi: UInt32 = 0
    var _gpsSupport: Bool = false
    var _stepSupport: Bool = false
    var _totalStep: UInt32 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _tranType = source._tranType
      _sportType = source._sportType
      _totalDurations = source._totalDurations
      _kmPace = source._kmPace
      _avgKmPace = source._avgKmPace
      _miPace = source._miPace
      _avgMiPace = source._avgMiPace
      _kmSpeed = source._kmSpeed
      _avgKmSpeed = source._avgKmSpeed
      _miSpeed = source._miSpeed
      _avgMiSpeed = source._avgMiSpeed
      _totalDistance = source._totalDistance
      _latitude = source._latitude
      _longitude = source._longitude
      _elevation = source._elevation
      _stepStride = source._stepStride
      _stepFrequency = source._stepFrequency
      _totalClimbHeight = source._totalClimbHeight
      _hrValue = source._hrValue
      _maxHrValue = source._maxHrValue
      _minHrValue = source._minHrValue
      _totalCalories = source._totalCalories
      _lapCount = source._lapCount
      _lapDuration = source._lapDuration
      _lapDistance = source._lapDistance
      _lapKmPaceSpeed = source._lapKmPaceSpeed
      _lapMiPaceSpeed = source._lapMiPaceSpeed
      _avgHrValue = source._avgHrValue
      _hrZone1Sec = source._hrZone1Sec
      _hrZone2Sec = source._hrZone2Sec
      _hrZone3Sec = source._hrZone3Sec
      _hrZone4Sec = source._hrZone4Sec
      _hrZone5Sec = source._hrZone5Sec
      _elevationSupport = source._elevationSupport
      _lapSupport = source._lapSupport
      _gpsRssi = source._gpsRssi
      _gpsSupport = source._gpsSupport
      _stepSupport = source._stepSupport
      _totalStep = source._totalStep
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._tranType) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._sportType) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._totalDurations) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._kmPace) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._avgKmPace) }()
        case 6: try { try decoder.decodeSingularUInt32Field(value: &_storage._miPace) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._avgMiPace) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._kmSpeed) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._avgKmSpeed) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._miSpeed) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._avgMiSpeed) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._totalDistance) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._latitude) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._longitude) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._elevation) }()
        case 16: try { try decoder.decodeSingularUInt32Field(value: &_storage._stepStride) }()
        case 17: try { try decoder.decodeSingularUInt32Field(value: &_storage._stepFrequency) }()
        case 18: try { try decoder.decodeSingularUInt32Field(value: &_storage._totalClimbHeight) }()
        case 19: try { try decoder.decodeSingularUInt32Field(value: &_storage._hrValue) }()
        case 20: try { try decoder.decodeSingularUInt32Field(value: &_storage._maxHrValue) }()
        case 21: try { try decoder.decodeSingularUInt32Field(value: &_storage._minHrValue) }()
        case 22: try { try decoder.decodeSingularUInt32Field(value: &_storage._totalCalories) }()
        case 23: try { try decoder.decodeSingularUInt32Field(value: &_storage._lapCount) }()
        case 24: try { try decoder.decodeSingularUInt32Field(value: &_storage._lapDuration) }()
        case 25: try { try decoder.decodeSingularUInt32Field(value: &_storage._lapDistance) }()
        case 26: try { try decoder.decodeSingularUInt32Field(value: &_storage._lapKmPaceSpeed) }()
        case 27: try { try decoder.decodeSingularUInt32Field(value: &_storage._lapMiPaceSpeed) }()
        case 28: try { try decoder.decodeSingularUInt32Field(value: &_storage._avgHrValue) }()
        case 29: try { try decoder.decodeSingularUInt32Field(value: &_storage._hrZone1Sec) }()
        case 30: try { try decoder.decodeSingularUInt32Field(value: &_storage._hrZone2Sec) }()
        case 31: try { try decoder.decodeSingularUInt32Field(value: &_storage._hrZone3Sec) }()
        case 32: try { try decoder.decodeSingularUInt32Field(value: &_storage._hrZone4Sec) }()
        case 33: try { try decoder.decodeSingularUInt32Field(value: &_storage._hrZone5Sec) }()
        case 34: try { try decoder.decodeSingularBoolField(value: &_storage._elevationSupport) }()
        case 35: try { try decoder.decodeSingularBoolField(value: &_storage._lapSupport) }()
        case 36: try { try decoder.decodeSingularUInt32Field(value: &_storage._gpsRssi) }()
        case 37: try { try decoder.decodeSingularBoolField(value: &_storage._gpsSupport) }()
        case 38: try { try decoder.decodeSingularBoolField(value: &_storage._stepSupport) }()
        case 39: try { try decoder.decodeSingularUInt32Field(value: &_storage._totalStep) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._tranType != .watchTran {
        try visitor.visitSingularEnumField(value: _storage._tranType, fieldNumber: 1)
      }
      if _storage._sportType != .orun {
        try visitor.visitSingularEnumField(value: _storage._sportType, fieldNumber: 2)
      }
      if _storage._totalDurations != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._totalDurations, fieldNumber: 3)
      }
      if _storage._kmPace != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._kmPace, fieldNumber: 4)
      }
      if _storage._avgKmPace != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._avgKmPace, fieldNumber: 5)
      }
      if _storage._miPace != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._miPace, fieldNumber: 6)
      }
      if _storage._avgMiPace != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._avgMiPace, fieldNumber: 7)
      }
      if _storage._kmSpeed != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._kmSpeed, fieldNumber: 8)
      }
      if _storage._avgKmSpeed != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._avgKmSpeed, fieldNumber: 9)
      }
      if _storage._miSpeed != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._miSpeed, fieldNumber: 10)
      }
      if _storage._avgMiSpeed != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._avgMiSpeed, fieldNumber: 11)
      }
      if _storage._totalDistance != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._totalDistance, fieldNumber: 12)
      }
      if _storage._latitude != 0 {
        try visitor.visitSingularInt32Field(value: _storage._latitude, fieldNumber: 13)
      }
      if _storage._longitude != 0 {
        try visitor.visitSingularInt32Field(value: _storage._longitude, fieldNumber: 14)
      }
      if _storage._elevation != 0 {
        try visitor.visitSingularInt32Field(value: _storage._elevation, fieldNumber: 15)
      }
      if _storage._stepStride != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._stepStride, fieldNumber: 16)
      }
      if _storage._stepFrequency != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._stepFrequency, fieldNumber: 17)
      }
      if _storage._totalClimbHeight != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._totalClimbHeight, fieldNumber: 18)
      }
      if _storage._hrValue != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._hrValue, fieldNumber: 19)
      }
      if _storage._maxHrValue != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._maxHrValue, fieldNumber: 20)
      }
      if _storage._minHrValue != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._minHrValue, fieldNumber: 21)
      }
      if _storage._totalCalories != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._totalCalories, fieldNumber: 22)
      }
      if _storage._lapCount != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._lapCount, fieldNumber: 23)
      }
      if _storage._lapDuration != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._lapDuration, fieldNumber: 24)
      }
      if _storage._lapDistance != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._lapDistance, fieldNumber: 25)
      }
      if _storage._lapKmPaceSpeed != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._lapKmPaceSpeed, fieldNumber: 26)
      }
      if _storage._lapMiPaceSpeed != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._lapMiPaceSpeed, fieldNumber: 27)
      }
      if _storage._avgHrValue != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._avgHrValue, fieldNumber: 28)
      }
      if _storage._hrZone1Sec != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._hrZone1Sec, fieldNumber: 29)
      }
      if _storage._hrZone2Sec != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._hrZone2Sec, fieldNumber: 30)
      }
      if _storage._hrZone3Sec != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._hrZone3Sec, fieldNumber: 31)
      }
      if _storage._hrZone4Sec != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._hrZone4Sec, fieldNumber: 32)
      }
      if _storage._hrZone5Sec != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._hrZone5Sec, fieldNumber: 33)
      }
      if _storage._elevationSupport != false {
        try visitor.visitSingularBoolField(value: _storage._elevationSupport, fieldNumber: 34)
      }
      if _storage._lapSupport != false {
        try visitor.visitSingularBoolField(value: _storage._lapSupport, fieldNumber: 35)
      }
      if _storage._gpsRssi != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._gpsRssi, fieldNumber: 36)
      }
      if _storage._gpsSupport != false {
        try visitor.visitSingularBoolField(value: _storage._gpsSupport, fieldNumber: 37)
      }
      if _storage._stepSupport != false {
        try visitor.visitSingularBoolField(value: _storage._stepSupport, fieldNumber: 38)
      }
      if _storage._totalStep != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._totalStep, fieldNumber: 39)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_exercise_sync_realtime_info, rhs: protocol_exercise_sync_realtime_info) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tranType != rhs_storage._tranType {return false}
        if _storage._sportType != rhs_storage._sportType {return false}
        if _storage._totalDurations != rhs_storage._totalDurations {return false}
        if _storage._kmPace != rhs_storage._kmPace {return false}
        if _storage._avgKmPace != rhs_storage._avgKmPace {return false}
        if _storage._miPace != rhs_storage._miPace {return false}
        if _storage._avgMiPace != rhs_storage._avgMiPace {return false}
        if _storage._kmSpeed != rhs_storage._kmSpeed {return false}
        if _storage._avgKmSpeed != rhs_storage._avgKmSpeed {return false}
        if _storage._miSpeed != rhs_storage._miSpeed {return false}
        if _storage._avgMiSpeed != rhs_storage._avgMiSpeed {return false}
        if _storage._totalDistance != rhs_storage._totalDistance {return false}
        if _storage._latitude != rhs_storage._latitude {return false}
        if _storage._longitude != rhs_storage._longitude {return false}
        if _storage._elevation != rhs_storage._elevation {return false}
        if _storage._stepStride != rhs_storage._stepStride {return false}
        if _storage._stepFrequency != rhs_storage._stepFrequency {return false}
        if _storage._totalClimbHeight != rhs_storage._totalClimbHeight {return false}
        if _storage._hrValue != rhs_storage._hrValue {return false}
        if _storage._maxHrValue != rhs_storage._maxHrValue {return false}
        if _storage._minHrValue != rhs_storage._minHrValue {return false}
        if _storage._totalCalories != rhs_storage._totalCalories {return false}
        if _storage._lapCount != rhs_storage._lapCount {return false}
        if _storage._lapDuration != rhs_storage._lapDuration {return false}
        if _storage._lapDistance != rhs_storage._lapDistance {return false}
        if _storage._lapKmPaceSpeed != rhs_storage._lapKmPaceSpeed {return false}
        if _storage._lapMiPaceSpeed != rhs_storage._lapMiPaceSpeed {return false}
        if _storage._avgHrValue != rhs_storage._avgHrValue {return false}
        if _storage._hrZone1Sec != rhs_storage._hrZone1Sec {return false}
        if _storage._hrZone2Sec != rhs_storage._hrZone2Sec {return false}
        if _storage._hrZone3Sec != rhs_storage._hrZone3Sec {return false}
        if _storage._hrZone4Sec != rhs_storage._hrZone4Sec {return false}
        if _storage._hrZone5Sec != rhs_storage._hrZone5Sec {return false}
        if _storage._elevationSupport != rhs_storage._elevationSupport {return false}
        if _storage._lapSupport != rhs_storage._lapSupport {return false}
        if _storage._gpsRssi != rhs_storage._gpsRssi {return false}
        if _storage._gpsSupport != rhs_storage._gpsSupport {return false}
        if _storage._stepSupport != rhs_storage._stepSupport {return false}
        if _storage._totalStep != rhs_storage._totalStep {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_exercise_control_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_exercise_control_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tran_type"),
    2: .standard(proto: "sport_type"),
    3: .standard(proto: "control_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.tranType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.sportType) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.controlType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tranType != .watchTran {
      try visitor.visitSingularEnumField(value: self.tranType, fieldNumber: 1)
    }
    if self.sportType != .orun {
      try visitor.visitSingularEnumField(value: self.sportType, fieldNumber: 2)
    }
    if self.controlType != .controlNull {
      try visitor.visitSingularEnumField(value: self.controlType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_exercise_control_operate, rhs: protocol_exercise_control_operate) -> Bool {
    if lhs.tranType != rhs.tranType {return false}
    if lhs.sportType != rhs.sportType {return false}
    if lhs.controlType != rhs.controlType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension course_list_item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "course_list_item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "Branch_id"),
    3: .standard(proto: "Creator_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.branchID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.creatorID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.branchID != 0 {
      try visitor.visitSingularUInt32Field(value: self.branchID, fieldNumber: 2)
    }
    if self.creatorID != 0 {
      try visitor.visitSingularUInt32Field(value: self.creatorID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: course_list_item, rhs: course_list_item) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.branchID != rhs.branchID {return false}
    if lhs.creatorID != rhs.creatorID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_exercise_course_list_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_exercise_course_list_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "list_items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.listItems) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .courseInvalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if !self.listItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.listItems, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_exercise_course_list_operate, rhs: protocol_exercise_course_list_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.listItems != rhs.listItems {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_exercise_course_list_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_exercise_course_list_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "func_table"),
    3: .standard(proto: "list_items"),
    4: .standard(proto: "target_support"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.funcTable) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.listItems) }()
      case 4: try { try decoder.decodeRepeatedEnumField(value: &self.targetSupport) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .courseInvalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.funcTable != 0 {
      try visitor.visitSingularUInt32Field(value: self.funcTable, fieldNumber: 2)
    }
    if !self.listItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.listItems, fieldNumber: 3)
    }
    if !self.targetSupport.isEmpty {
      try visitor.visitPackedEnumField(value: self.targetSupport, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_exercise_course_list_inquire_reply, rhs: protocol_exercise_course_list_inquire_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.funcTable != rhs.funcTable {return false}
    if lhs.listItems != rhs.listItems {return false}
    if lhs.targetSupport != rhs.targetSupport {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_total_mileage_item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_total_mileage_item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sport_type"),
    2: .standard(proto: "time_type"),
    3: .standard(proto: "target_type"),
    4: .standard(proto: "cur_activity_count"),
    5: .standard(proto: "cur_distance"),
    6: .standard(proto: "goal_activity_count"),
    7: .standard(proto: "goal_distance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.sportType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.timeType) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.targetType) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.curActivityCount) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.curDistance) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.goalActivityCount) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.goalDistance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sportType != .mileageNull {
      try visitor.visitSingularEnumField(value: self.sportType, fieldNumber: 1)
    }
    if self.timeType != .weekly {
      try visitor.visitSingularEnumField(value: self.timeType, fieldNumber: 2)
    }
    if self.targetType != .activity {
      try visitor.visitSingularEnumField(value: self.targetType, fieldNumber: 3)
    }
    if self.curActivityCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.curActivityCount, fieldNumber: 4)
    }
    if self.curDistance != 0 {
      try visitor.visitSingularUInt32Field(value: self.curDistance, fieldNumber: 5)
    }
    if self.goalActivityCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.goalActivityCount, fieldNumber: 6)
    }
    if self.goalDistance != 0 {
      try visitor.visitSingularUInt32Field(value: self.goalDistance, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_total_mileage_item, rhs: protocol_total_mileage_item) -> Bool {
    if lhs.sportType != rhs.sportType {return false}
    if lhs.timeType != rhs.timeType {return false}
    if lhs.targetType != rhs.targetType {return false}
    if lhs.curActivityCount != rhs.curActivityCount {return false}
    if lhs.curDistance != rhs.curDistance {return false}
    if lhs.goalActivityCount != rhs.goalActivityCount {return false}
    if lhs.goalDistance != rhs.goalDistance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_exercise_total_mileage_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_exercise_total_mileage_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "mileage_item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._mileageItem) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    try { if let v = self._mileageItem {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_exercise_total_mileage_operate, rhs: protocol_exercise_total_mileage_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs._mileageItem != rhs._mileageItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_exercise_total_mileage_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_exercise_total_mileage_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "func_table"),
    3: .standard(proto: "mileage_item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.funcTable) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._mileageItem) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.funcTable != 0 {
      try visitor.visitSingularUInt32Field(value: self.funcTable, fieldNumber: 2)
    }
    try { if let v = self._mileageItem {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_exercise_total_mileage_inquire_reply, rhs: protocol_exercise_total_mileage_inquire_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.funcTable != rhs.funcTable {return false}
    if lhs._mileageItem != rhs._mileageItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension action_list_item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "action_list_item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "version"),
    3: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 2)
    }
    if self.type != 0 {
      try visitor.visitSingularUInt32Field(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: action_list_item, rhs: action_list_item) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.version != rhs.version {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_exercise_action_list_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_exercise_action_list_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "list_items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.listItems) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .courseInvalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if !self.listItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.listItems, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_exercise_action_list_operate, rhs: protocol_exercise_action_list_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.listItems != rhs.listItems {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_action_list_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_action_list_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .standard(proto: "func_table"),
    3: .standard(proto: "list_items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.funcTable) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.listItems) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operate != .courseInvalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    if self.funcTable != 0 {
      try visitor.visitSingularUInt32Field(value: self.funcTable, fieldNumber: 2)
    }
    if !self.listItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.listItems, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_action_list_inquire_reply, rhs: protocol_action_list_inquire_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs.funcTable != rhs.funcTable {return false}
    if lhs.listItems != rhs.listItems {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
