// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: prayer.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct prayer_time: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///1bytes
  public var hour: UInt32 = 0

  ///1bytes
  public var minute: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct prayer_data: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///晨礼时间
  public var fajrTime: prayer_time {
    get {return _fajrTime ?? prayer_time()}
    set {_fajrTime = newValue}
  }
  /// Returns true if `fajrTime` has been explicitly set.
  public var hasFajrTime: Bool {return self._fajrTime != nil}
  /// Clears the value of `fajrTime`. Subsequent reads from it will return its default value.
  public mutating func clearFajrTime() {self._fajrTime = nil}

  ///日出时间
  public var sunriseTime: prayer_time {
    get {return _sunriseTime ?? prayer_time()}
    set {_sunriseTime = newValue}
  }
  /// Returns true if `sunriseTime` has been explicitly set.
  public var hasSunriseTime: Bool {return self._sunriseTime != nil}
  /// Clears the value of `sunriseTime`. Subsequent reads from it will return its default value.
  public mutating func clearSunriseTime() {self._sunriseTime = nil}

  ///晌礼时间
  public var dhuhrTime: prayer_time {
    get {return _dhuhrTime ?? prayer_time()}
    set {_dhuhrTime = newValue}
  }
  /// Returns true if `dhuhrTime` has been explicitly set.
  public var hasDhuhrTime: Bool {return self._dhuhrTime != nil}
  /// Clears the value of `dhuhrTime`. Subsequent reads from it will return its default value.
  public mutating func clearDhuhrTime() {self._dhuhrTime = nil}

  ///晡礼时间
  public var asrTime: prayer_time {
    get {return _asrTime ?? prayer_time()}
    set {_asrTime = newValue}
  }
  /// Returns true if `asrTime` has been explicitly set.
  public var hasAsrTime: Bool {return self._asrTime != nil}
  /// Clears the value of `asrTime`. Subsequent reads from it will return its default value.
  public mutating func clearAsrTime() {self._asrTime = nil}

  ///昏礼时间
  public var maghribTime: prayer_time {
    get {return _maghribTime ?? prayer_time()}
    set {_maghribTime = newValue}
  }
  /// Returns true if `maghribTime` has been explicitly set.
  public var hasMaghribTime: Bool {return self._maghribTime != nil}
  /// Clears the value of `maghribTime`. Subsequent reads from it will return its default value.
  public mutating func clearMaghribTime() {self._maghribTime = nil}

  ///宵礼时间
  public var ishaTime: prayer_time {
    get {return _ishaTime ?? prayer_time()}
    set {_ishaTime = newValue}
  }
  /// Returns true if `ishaTime` has been explicitly set.
  public var hasIshaTime: Bool {return self._ishaTime != nil}
  /// Clears the value of `ishaTime`. Subsequent reads from it will return its default value.
  public mutating func clearIshaTime() {self._ishaTime = nil}

  ///4bytes 伊斯兰历日期
  public var date: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fajrTime: prayer_time? = nil
  fileprivate var _sunriseTime: prayer_time? = nil
  fileprivate var _dhuhrTime: prayer_time? = nil
  fileprivate var _asrTime: prayer_time? = nil
  fileprivate var _maghribTime: prayer_time? = nil
  fileprivate var _ishaTime: prayer_time? = nil
}

public struct protocol_prayer: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///max:3 3天的祷告数据
  public var data: [prayer_data] = []

  ///max:64 城市名
  public var cityName: Data = Data()

  ///2bytes 天房位置，偏向角度
  public var roomAngle: UInt32 = 0

  ///4bytes 最近同步的伊斯兰历时间
  public var updatedTime: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct protocol_prayer_operate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  public var prayer: protocol_prayer {
    get {return _prayer ?? protocol_prayer()}
    set {_prayer = newValue}
  }
  /// Returns true if `prayer` has been explicitly set.
  public var hasPrayer: Bool {return self._prayer != nil}
  /// Clears the value of `prayer`. Subsequent reads from it will return its default value.
  public mutating func clearPrayer() {self._prayer = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prayer: protocol_prayer? = nil
}

public struct protocol_prayer_inquire_reply: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///操作类型 0：无效操作 1：查询 2：设置
  public var operate: operate_type = .invalid

  public var prayer: protocol_prayer {
    get {return _prayer ?? protocol_prayer()}
    set {_prayer = newValue}
  }
  /// Returns true if `prayer` has been explicitly set.
  public var hasPrayer: Bool {return self._prayer != nil}
  /// Clears the value of `prayer`. Subsequent reads from it will return its default value.
  public mutating func clearPrayer() {self._prayer = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prayer: protocol_prayer? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension prayer_time: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "prayer_time"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hour"),
    2: .same(proto: "minute"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.hour) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.minute) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hour != 0 {
      try visitor.visitSingularUInt32Field(value: self.hour, fieldNumber: 1)
    }
    if self.minute != 0 {
      try visitor.visitSingularUInt32Field(value: self.minute, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: prayer_time, rhs: prayer_time) -> Bool {
    if lhs.hour != rhs.hour {return false}
    if lhs.minute != rhs.minute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension prayer_data: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "prayer_data"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fajr_time"),
    2: .standard(proto: "sunrise_time"),
    3: .standard(proto: "dhuhr_time"),
    4: .standard(proto: "asr_time"),
    5: .standard(proto: "maghrib_time"),
    6: .standard(proto: "isha_time"),
    7: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fajrTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sunriseTime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._dhuhrTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._asrTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._maghribTime) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._ishaTime) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fajrTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sunriseTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._dhuhrTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._asrTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._maghribTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._ishaTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.date != 0 {
      try visitor.visitSingularUInt32Field(value: self.date, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: prayer_data, rhs: prayer_data) -> Bool {
    if lhs._fajrTime != rhs._fajrTime {return false}
    if lhs._sunriseTime != rhs._sunriseTime {return false}
    if lhs._dhuhrTime != rhs._dhuhrTime {return false}
    if lhs._asrTime != rhs._asrTime {return false}
    if lhs._maghribTime != rhs._maghribTime {return false}
    if lhs._ishaTime != rhs._ishaTime {return false}
    if lhs.date != rhs.date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_prayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_prayer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .standard(proto: "city_name"),
    3: .standard(proto: "room_angle"),
    4: .standard(proto: "updated_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.cityName) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.roomAngle) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.updatedTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    if !self.cityName.isEmpty {
      try visitor.visitSingularBytesField(value: self.cityName, fieldNumber: 2)
    }
    if self.roomAngle != 0 {
      try visitor.visitSingularUInt32Field(value: self.roomAngle, fieldNumber: 3)
    }
    if self.updatedTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.updatedTime, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_prayer, rhs: protocol_prayer) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.cityName != rhs.cityName {return false}
    if lhs.roomAngle != rhs.roomAngle {return false}
    if lhs.updatedTime != rhs.updatedTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_prayer_operate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_prayer_operate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .same(proto: "prayer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._prayer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    try { if let v = self._prayer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_prayer_operate, rhs: protocol_prayer_operate) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs._prayer != rhs._prayer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension protocol_prayer_inquire_reply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "protocol_prayer_inquire_reply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operate"),
    2: .same(proto: "prayer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._prayer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.operate != .invalid {
      try visitor.visitSingularEnumField(value: self.operate, fieldNumber: 1)
    }
    try { if let v = self._prayer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: protocol_prayer_inquire_reply, rhs: protocol_prayer_inquire_reply) -> Bool {
    if lhs.operate != rhs.operate {return false}
    if lhs._prayer != rhs._prayer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
